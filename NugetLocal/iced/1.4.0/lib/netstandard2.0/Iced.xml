<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Iced</name>
    </assembly>
    <members>
        <member name="T:Iced.Intel.RelocKind">
            <summary>
            Relocation kind
            </summary>
        </member>
        <member name="F:Iced.Intel.RelocKind.Offset64">
            <summary>
            64-bit offset. Only used if it's 64-bit code.
            </summary>
        </member>
        <member name="T:Iced.Intel.RelocInfo">
            <summary>
            Relocation info
            </summary>
        </member>
        <member name="F:Iced.Intel.RelocInfo.Address">
            <summary>
            Address
            </summary>
        </member>
        <member name="F:Iced.Intel.RelocInfo.Kind">
            <summary>
            Relocation kind
            </summary>
        </member>
        <member name="M:Iced.Intel.RelocInfo.#ctor(Iced.Intel.RelocKind,System.UInt64)">
            <summary>
            Constructor
            </summary>
            <param name="kind">Relocation kind</param>
            <param name="address">Address</param>
        </member>
        <member name="T:Iced.Intel.InstructionBlock">
            <summary>
            Contains a list of instructions and a base IP
            </summary>
        </member>
        <member name="F:Iced.Intel.InstructionBlock.CodeWriter">
            <summary>
            Code writer
            </summary>
        </member>
        <member name="F:Iced.Intel.InstructionBlock.Instructions">
            <summary>
            All instructions
            </summary>
        </member>
        <member name="F:Iced.Intel.InstructionBlock.RIP">
            <summary>
            Base IP of all encoded instructions
            </summary>
        </member>
        <member name="F:Iced.Intel.InstructionBlock.RelocInfos">
            <summary>
            List that gets all reloc infos or null
            </summary>
        </member>
        <member name="F:Iced.Intel.InstructionBlock.NewInstructionOffsets">
            <summary>
            Offsets of the new instructions relative to the base IP. If the instruction was rewritten to
            a completely different instruction, the value <see cref="F:System.UInt32.MaxValue"/> is stored in that array element.
            This array can be null.
            </summary>
        </member>
        <member name="F:Iced.Intel.InstructionBlock.ConstantOffsets">
            <summary>
            Offsets of all constants in the new encoded instructions. If the instruction was rewritten,
            the 'default' value is stored in the corresponding array element. This array can be null.
            </summary>
        </member>
        <member name="M:Iced.Intel.InstructionBlock.#ctor(Iced.Intel.CodeWriter,System.Collections.Generic.IList{Iced.Intel.Instruction},System.UInt64,System.Collections.Generic.IList{Iced.Intel.RelocInfo},System.UInt32[],Iced.Intel.ConstantOffsets[])">
            <summary>
            Constructor
            </summary>
            <param name="codeWriter">Code writer</param>
            <param name="instructions">Instructions</param>
            <param name="rip">Base IP of all encoded instructions</param>
            <param name="relocInfos">List that gets all reloc infos or null</param>
            <param name="newInstructionOffsets">Offsets of the new instructions relative to the base IP. If the instruction was rewritten to
            a completely different instruction, the value <see cref="F:System.UInt32.MaxValue"/> is stored in that array element.
            This array can be null.</param>
            <param name="constantOffsets">Offsets of all constants in the new encoded instructions. If the instruction was rewritten,
            the 'default' value is stored in the corresponding array element. This array can be null.</param>
        </member>
        <member name="T:Iced.Intel.BlockEncoderOptions">
            <summary>
            Encoder options
            </summary>
        </member>
        <member name="F:Iced.Intel.BlockEncoderOptions.None">
            <summary>
            No option is set
            </summary>
        </member>
        <member name="F:Iced.Intel.BlockEncoderOptions.DontFixBranches">
            <summary>
            By default, branches get updated if the target is too far away, eg. jcc short -> jcc near
            or if 64-bit mode, jcc + jmp [rip+mem]. If this option is enabled, no branches are fixed.
            </summary>
        </member>
        <member name="T:Iced.Intel.BlockEncoder">
            <summary>
            Encodes instructions
            </summary>
        </member>
        <member name="M:Iced.Intel.BlockEncoder.TryEncode(System.Int32,Iced.Intel.InstructionBlock,System.String@,Iced.Intel.BlockEncoderOptions)">
            <summary>
            Encodes instructions. Returns null or an error message
            </summary>
            <param name="bitness">16, 32 or 64</param>
            <param name="block">All instructions</param>
            <param name="errorMessage">Updated with an error message if the method failed</param>
            <param name="options">Encoder options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.BlockEncoder.TryEncode(System.Int32,Iced.Intel.InstructionBlock[],System.String@,Iced.Intel.BlockEncoderOptions)">
            <summary>
            Encodes instructions. Returns null or an error message
            </summary>
            <param name="bitness">16, 32 or 64</param>
            <param name="blocks">All instructions</param>
            <param name="errorMessage">Updated with an error message if the method failed</param>
            <param name="options">Encoder options</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.BlockEncoderInternal.CallInstr">
            <summary>
            Call near instruction
            </summary>
        </member>
        <member name="M:Iced.Intel.BlockEncoderInternal.Instr.Initialize">
            <summary>
            Initializes the target address and tries to optimize the instruction
            </summary>
        </member>
        <member name="M:Iced.Intel.BlockEncoderInternal.Instr.Optimize">
            <summary>
            Returns true if the instruction was updated to a shorter instruction, false if nothing changed
            </summary>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.BlockEncoderInternal.IpRelMemOpInstr">
            <summary>
            Instruction with a memory operand that is RIP/EIP relative
            </summary>
        </member>
        <member name="T:Iced.Intel.BlockEncoderInternal.JccInstr">
            <summary>
            Jcc instruction
            </summary>
        </member>
        <member name="T:Iced.Intel.BlockEncoderInternal.JmpInstr">
            <summary>
            Jmp instruction
            </summary>
        </member>
        <member name="T:Iced.Intel.BlockEncoderInternal.SimpleBranchInstr">
            <summary>
            Simple branch instruction that only has one code value, eg. loopcc, jrcxz
            </summary>
        </member>
        <member name="T:Iced.Intel.BlockEncoderInternal.SimpleInstr">
            <summary>
            Simple instruction that doesn't need fixing, i.e., it's not IP relative (no branch instruction, no IP relative memory operand)
            </summary>
        </member>
        <member name="T:Iced.Intel.BlockEncoderInternal.XbeginInstr">
            <summary>
            Xbegin instruction
            </summary>
        </member>
        <member name="T:Iced.Intel.ByteArrayCodeReader">
            <summary>
            A <see cref="T:Iced.Intel.CodeReader"/> that reads data from a byte array
            </summary>
        </member>
        <member name="P:Iced.Intel.ByteArrayCodeReader.Position">
            <summary>
            Current position
            </summary>
        </member>
        <member name="P:Iced.Intel.ByteArrayCodeReader.Count">
            <summary>
            Number of bytes that can be read
            </summary>
        </member>
        <member name="P:Iced.Intel.ByteArrayCodeReader.CanReadByte">
            <summary>
            Checks if it's possible to read another byte
            </summary>
        </member>
        <member name="M:Iced.Intel.ByteArrayCodeReader.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="hexData">Hex bytes encoded in a string</param>
        </member>
        <member name="M:Iced.Intel.ByteArrayCodeReader.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Data</param>
        </member>
        <member name="M:Iced.Intel.ByteArrayCodeReader.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="data">Data</param>
            <param name="index">Start index</param>
            <param name="count">Number of bytes</param>
        </member>
        <member name="M:Iced.Intel.ByteArrayCodeReader.#ctor(System.ArraySegment{System.Byte})">
            <summary>
            Constructor
            </summary>
            <param name="data">Data</param>
        </member>
        <member name="M:Iced.Intel.ByteArrayCodeReader.ReadByte">
            <summary>
            Reads the next byte or returns less than 0 if there are no more bytes
            </summary>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.Code">
            <summary>
            x86 instruction code
            </summary>
        </member>
        <member name="F:Iced.Intel.Code.INVALID">
            <summary>
            It's an invalid instruction, eg. it's a new unknown instruction, garbage or
            there's not enough bytes to decode the instruction etc.
            </summary>
        </member>
        <member name="F:Iced.Intel.Code.DeclareByte">
            <summary>
            A 'db' asm directive that can store 1-16 bytes
            </summary>
        </member>
        <member name="F:Iced.Intel.Code.DeclareWord">
            <summary>
            A 'dw' asm directive that can store 1-8 words
            </summary>
        </member>
        <member name="F:Iced.Intel.Code.DeclareDword">
            <summary>
            A 'dd' asm directive that can store 1-4 dwords
            </summary>
        </member>
        <member name="F:Iced.Intel.Code.DeclareQword">
            <summary>
            A 'dq' asm directive that can store 1-2 qwords
            </summary>
        </member>
        <member name="T:Iced.Intel.CodeReader">
            <summary>
            Reads instruction bytes
            </summary>
        </member>
        <member name="M:Iced.Intel.CodeReader.ReadByte">
            <summary>
            Reads the next byte or returns less than 0 if there are no more bytes
            </summary>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.CodeSize">
            <summary>
            Default code size when an instruction was decoded
            </summary>
        </member>
        <member name="F:Iced.Intel.CodeSize.Unknown">
            <summary>
            Unknown size
            </summary>
        </member>
        <member name="F:Iced.Intel.CodeSize.Code16">
            <summary>
            16-bit code
            </summary>
        </member>
        <member name="F:Iced.Intel.CodeSize.Code32">
            <summary>
            32-bit code
            </summary>
        </member>
        <member name="F:Iced.Intel.CodeSize.Code64">
            <summary>
            64-bit code
            </summary>
        </member>
        <member name="T:Iced.Intel.CodeWriter">
            <summary>
            Used by an <see cref="T:Iced.Intel.Encoder"/> to write encoded instructions
            </summary>
        </member>
        <member name="M:Iced.Intel.CodeWriter.WriteByte(System.Byte)">
            <summary>
            Writes the next byte
            </summary>
            <param name="value">Value</param>
        </member>
        <member name="T:Iced.Intel.ConditionCode">
            <summary>
            Instruction condition code (used by jcc, setcc, cmovcc)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.None">
            <summary>
            The instruction doesn't have a condition code
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.o">
            <summary>
            Overflow (OF=1)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.no">
            <summary>
            Not overflow (OF=0)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.b">
            <summary>
            Below (unsigned) (CF=1)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.ae">
            <summary>
            Above or equal (unsigned) (CF=0)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.e">
            <summary>
            Equal / zero (ZF=1)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.ne">
            <summary>
            Not equal / zero (ZF=0)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.be">
            <summary>
            Below or equal (unsigned) (CF=1 or ZF=1)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.a">
            <summary>
            Above (unsigned) (CF=0 and ZF=0)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.s">
            <summary>
            Signed (SF=1)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.ns">
            <summary>
            Not signed (SF=0)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.p">
            <summary>
            Parity (PF=1)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.np">
            <summary>
            Not parity (PF=0)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.l">
            <summary>
            Less (signed) (SF!=OF)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.ge">
            <summary>
            Greater than or equal (signed) (SF=OF)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.le">
            <summary>
            Less than or equal (signed) (ZF=1 or SF!=OF)
            </summary>
        </member>
        <member name="F:Iced.Intel.ConditionCode.g">
            <summary>
            Greater (signed) (ZF=0 and SF=OF)
            </summary>
        </member>
        <member name="T:Iced.Intel.ConstantOffsets">
            <summary>
            Contains the offsets of the displacement and immediate. Call decoder's GetConstantOffsets() method
            to get the offsets of the constants after the instruction has been decoded. The encoder has a similar method.
            </summary>
        </member>
        <member name="F:Iced.Intel.ConstantOffsets.DisplacementOffset">
            <summary>
            The offset of the displacement, if any
            </summary>
        </member>
        <member name="F:Iced.Intel.ConstantOffsets.DisplacementSize">
            <summary>
            Size of the displacement in bytes, or 0 if there's no displacement
            </summary>
        </member>
        <member name="F:Iced.Intel.ConstantOffsets.ImmediateOffset">
            <summary>
            The offset of the first immediate, if any.
            
            This field can be invalid even if the operand has an immediate if it's an immediate that isn't part
            of the instruction stream, eg. 'shl al,1'.
            </summary>
        </member>
        <member name="F:Iced.Intel.ConstantOffsets.ImmediateSize">
            <summary>
            Size of the first immediate in bytes, or 0 if there's no immediate
            </summary>
        </member>
        <member name="F:Iced.Intel.ConstantOffsets.ImmediateOffset2">
            <summary>
            The offset of the second immediate, if any.
            </summary>
        </member>
        <member name="F:Iced.Intel.ConstantOffsets.ImmediateSize2">
            <summary>
            Size of the second immediate in bytes, or 0 if there's no second immediate
            </summary>
        </member>
        <member name="P:Iced.Intel.ConstantOffsets.HasDisplacement">
            <summary>
            true if <see cref="F:Iced.Intel.ConstantOffsets.DisplacementOffset"/> is valid
            </summary>
        </member>
        <member name="P:Iced.Intel.ConstantOffsets.HasImmediate">
            <summary>
            true if <see cref="F:Iced.Intel.ConstantOffsets.ImmediateOffset"/> is valid
            </summary>
        </member>
        <member name="P:Iced.Intel.ConstantOffsets.HasImmediate2">
            <summary>
            true if <see cref="F:Iced.Intel.ConstantOffsets.ImmediateOffset2"/> is valid
            </summary>
        </member>
        <member name="T:Iced.Intel.CpuidFeature">
            <summary>
            CPUID feature flags
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL8086">
            <summary>
            8086 or later
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL8086_ONLY">
            <summary>
            8086 only
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL186">
            <summary>
            80186 or later
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL286">
            <summary>
            80286 or later
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL286_ONLY">
            <summary>
            80286 only
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL386">
            <summary>
            80386 or later
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL386_ONLY">
            <summary>
            80386 only
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL386_A0_ONLY">
            <summary>
            80386 A0-B0 stepping only (xbts, ibts instructions)
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL486">
            <summary>
            Intel486 or later
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL486_A_ONLY">
            <summary>
            Intel486 A stepping only (cmpxchg)
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INTEL386_486_ONLY">
            <summary>
            80386 and Intel486 only
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.IA64">
            <summary>
            IA-64
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.X64">
            <summary>
            CPUID.80000001H:EDX.LM[bit 29]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.ADX">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AES">
            <summary>
            CPUID.01H:ECX.AES[bit 25]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX">
            <summary>
            CPUID.01H:ECX.AVX[bit 28]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX2">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.AVX2[bit 5]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512_4FMAPS">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EDX.AVX512_4FMAPS[bit 3]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512_4VNNIW">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EDX.AVX512_4VNNIW[bit 2]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512_BF16">
            <summary>
            CPUID.(EAX=07H, ECX=1):EAX[bit 5]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512_BITALG">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.AVX512_BITALG[bit 12]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512_IFMA">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.AVX512_IFMA[bit 21]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512_VBMI">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.AVX512_VBMI[bit 1]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512_VBMI2">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.AVX512_VBMI2[bit 6] 
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512_VNNI">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.AVX512_VNNI[bit 11]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512_VP2INTERSECT">
            <summary>
            CPUID.(EAX=07H, ECX=0):EDX[bit 08]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512_VPOPCNTDQ">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.AVX512_VPOPCNTDQ[bit 14]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512BW">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.AVX512BW[bit 30]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512CD">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.AVX512CD[bit 28]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512DQ">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.AVX512DQ[bit 17]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512ER">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.AVX512ER[bit 27]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512F">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.AVX512F[bit 16]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512PF">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.AVX512PF[bit 26]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.AVX512VL">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.AVX512VL[bit 31]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.BMI1">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.BMI1[bit 3]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.BMI2">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.BMI2[bit 8]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CET_IBT">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EDX.CET_IBT[bit 20]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CET_SS">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[bit 7]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CL1INVMB">
            <summary>
            CL1INVMB instruction (Intel SCC = Single-Chip Computer)
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CLDEMOTE">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.CLDEMOTE[bit 25]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CLFLUSHOPT">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.CLFLUSHOPT[bit 23]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CLFSH">
            <summary>
            CPUID.01H:EDX.CLFSH[bit 19]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CLWB">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.CLWB[bit 24]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CLZERO">
            <summary>
            CPUID.80000008H:EBX.CLZERO[bit 0]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CMOV">
            <summary>
            CPUID.01H:EDX.CMOV[bit 15]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CMPXCHG16B">
            <summary>
            CPUID.01H:ECX.CMPXCHG16B[bit 13]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CPUID">
            <summary>
            RFLAGS.ID can be toggled
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.CX8">
            <summary>
            CPUID.01H:EDX.CX8[bit 8]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.D3NOW">
            <summary>
            CPUID.80000001H:EDX.3DNOW[bit 31]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.D3NOWEXT">
            <summary>
            CPUID.80000001H:EDX.3DNOWEXT[bit 30]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.ENCLV">
            <summary>
            CPUID.(EAX=12H, ECX=0H):EAX.OSS[bit 5]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.ENQCMD">
            <summary>
            CPUID.(EAX=07H, ECX=0):ECX[bit 29]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.F16C">
            <summary>
            CPUID.01H:ECX.F16C[bit 29]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.FMA">
            <summary>
            CPUID.01H:ECX.FMA[bit 12]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.FMA4">
            <summary>
            CPUID.80000001H:ECX.FMA4[bit 16]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.FPU">
            <summary>
            8087 or later (CPUID.01H:EDX.FPU[bit 0])
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.FPU287">
            <summary>
            80287 or later
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.FPU287XL_ONLY">
            <summary>
            80287XL only
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.FPU387">
            <summary>
            80387 or later
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.FPU387SL_ONLY">
            <summary>
            80387SL only
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.FSGSBASE">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.FSGSBASE[bit 0]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.FXSR">
            <summary>
            CPUID.01H:EDX.FXSR[bit 24]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.GEODE">
            <summary>
            AMD Geode LX/GX CPU
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.GFNI">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.GFNI[bit 8]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.HLE">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.HLE[bit 4]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.HLE_or_RTM">
            <summary>
            <see cref="F:Iced.Intel.CpuidFeature.HLE"/> or <see cref="F:Iced.Intel.CpuidFeature.RTM"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INVEPT">
            <summary>
            <see cref="F:Iced.Intel.CpuidFeature.VMX"/> and IA32_VMX_EPT_VPID_CAP[bit 20]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INVPCID">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.INVPCID[bit 10]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.INVVPID">
            <summary>
            <see cref="F:Iced.Intel.CpuidFeature.VMX"/> and IA32_VMX_EPT_VPID_CAP[bit 32]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.LWP">
            <summary>
            CPUID.80000001H:ECX.LWP[bit 15]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.LZCNT">
            <summary>
            CPUID.80000001H:ECX.LZCNT[bit 5]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.MCOMMIT">
            <summary>
            CPUID.80000008H:EBX.MCOMMIT[bit 8]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.MMX">
            <summary>
            CPUID.01H:EDX.MMX[bit 23]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.MONITOR">
            <summary>
            CPUID.01H:ECX.MONITOR[bit 3]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.MONITORX">
            <summary>
            CPUID.80000001H:ECX.MONITORX[bit 29]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.MOVBE">
            <summary>
            CPUID.01H:ECX.MOVBE[bit 22]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.MOVDIR64B">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.MOVDIR64B[bit 28]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.MOVDIRI">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.MOVDIRI[bit 27]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.MPX">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.MPX[bit 14]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.MSR">
            <summary>
            CPUID.01H:EDX.MSR[bit 5]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.MULTIBYTENOP">
            <summary>
            Multi-byte nops (0F1F /0): CPUID.01H.EAX[Bits 11:8] = 0110B or 1111B
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PADLOCK_ACE">
            <summary>
            CPUID.0C0000000H:EAX >= 0C0000001H AND CPUID.0C0000001H:EDX.ACE[Bits 7:6] = 11B ([6] = exists, [7] = enabled)
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PADLOCK_PHE">
            <summary>
            CPUID.0C0000000H:EAX >= 0C0000001H AND CPUID.0C0000001H:EDX.PHE[Bits 11:10] = 11B ([10] = exists, [11] = enabled)
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PADLOCK_PMM">
            <summary>
            CPUID.0C0000000H:EAX >= 0C0000001H AND CPUID.0C0000001H:EDX.PMM[Bits 13:12] = 11B ([12] = exists, [13] = enabled)
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PADLOCK_RNG">
            <summary>
            CPUID.0C0000000H:EAX >= 0C0000001H AND CPUID.0C0000001H:EDX.RNG[Bits 3:2] = 11B ([2] = exists, [3] = enabled)
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PAUSE">
            <summary>
            PAUSE instruction (Pentium 4 or later)
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PCLMULQDQ">
            <summary>
            CPUID.01H:ECX.PCLMULQDQ[bit 1]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PCOMMIT">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.PCOMMIT[bit 22]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PCONFIG">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EDX.PCONFIG[bit 18]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PKU">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.PKU[bit 3]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.POPCNT">
            <summary>
            CPUID.01H:ECX.POPCNT[bit 23]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PREFETCHW">
            <summary>
            CPUID.80000001H:ECX.PREFETCHW[bit 8]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PREFETCHWT1">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.PREFETCHWT1[bit 0]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.PTWRITE">
            <summary>
            CPUID.(EAX=14H, ECX=0H):EBX.PTWRITE[bit 4]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.RDPID">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.RDPID[bit 22]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.RDPMC">
            <summary>
            RDPMC instruction (Pentium MMX or later, or Pentium Pro or later)
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.RDPRU">
            <summary>
            CPUID.80000008H:EBX.RDPRU[bit 4]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.RDRAND">
            <summary>
            CPUID.01H:ECX.RDRAND[bit 30]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.RDSEED">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.RDSEED[bit 18]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.RDTSCP">
            <summary>
            CPUID.80000001H:EDX.RDTSCP[bit 27]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.RTM">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.RTM[bit 11]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SEP">
            <summary>
            CPUID.01H:EDX.SEP[bit 11]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SGX1">
            <summary>
            CPUID.(EAX=12H, ECX=0H):EAX.SGX1[bit 0]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SHA">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.SHA[bit 29]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SKINIT">
            <summary>
            CPUID.80000001H:ECX.SKINIT[bit 12]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SKINIT_or_SVML">
            <summary>
            <see cref="F:Iced.Intel.CpuidFeature.SKINIT"/> or <see cref="F:Iced.Intel.CpuidFeature.SVML"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SMAP">
            <summary>
            CPUID.(EAX=07H, ECX=0H):EBX.SMAP[bit 20]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SMX">
            <summary>
            CPUID.01H:ECX.SMX[bit 6]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SSE">
            <summary>
            CPUID.01H:EDX.SSE[bit 25]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SSE2">
            <summary>
            CPUID.01H:EDX.SSE2[bit 26]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SSE3">
            <summary>
            CPUID.01H:ECX.SSE3[bit 0]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SSE4_1">
            <summary>
            CPUID.01H:ECX.SSE4_1[bit 19]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SSE4_2">
            <summary>
            CPUID.01H:ECX.SSE4_2[bit 20]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SSE4A">
            <summary>
            CPUID.80000001H:ECX.SSE4A[bit 6]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SSSE3">
            <summary>
            CPUID.01H:ECX.SSSE3[bit 9]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SVM">
            <summary>
            CPUID.80000001H:ECX.SVM[bit 2]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SVML">
            <summary>
            CPUID.8000000AH:EDX.SVML[bit 2]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.SYSCALL">
            <summary>
            CPUID.80000001H:EDX.SYSCALL[bit 11]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.TBM">
            <summary>
            CPUID.80000001H:ECX.TBM[bit 21]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.TSC">
            <summary>
            CPUID.01H:EDX.TSC[bit 4]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.VAES">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.VAES[bit 9]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.VMX">
            <summary>
            CPUID.01H:ECX.VMX[bit 5]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.VPCLMULQDQ">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.VPCLMULQDQ[bit 10]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.WAITPKG">
            <summary>
            CPUID.(EAX=07H, ECX=0H):ECX.WAITPKG[bit 5]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.WBNOINVD">
            <summary>
            CPUID.(EAX=80000008H, ECX=0H):EBX.WBNOINVD[bit 9]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.XOP">
            <summary>
            CPUID.80000001H:ECX.XOP[bit 11]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.XSAVE">
            <summary>
            CPUID.01H:ECX.XSAVE[bit 26]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.XSAVEC">
            <summary>
            CPUID.(EAX=0DH, ECX=1H):EAX.XSAVEC[bit 1]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.XSAVEOPT">
            <summary>
            CPUID.(EAX=0DH, ECX=1H):EAX.XSAVEOPT[bit 0]
            </summary>
        </member>
        <member name="F:Iced.Intel.CpuidFeature.XSAVES">
            <summary>
            CPUID.(EAX=0DH, ECX=1H):EAX.XSAVES[bit 3]
            </summary>
        </member>
        <member name="T:Iced.Intel.Decoder">
            <summary>
            Decodes 16/32/64-bit x86 instructions
            </summary>
        </member>
        <member name="P:Iced.Intel.Decoder.InstructionPointer">
            <summary>
            Current IP/EIP/RIP value
            </summary>
        </member>
        <member name="P:Iced.Intel.Decoder.IP">
            <summary>
            Current IP/EIP/RIP value
            </summary>
        </member>
        <member name="P:Iced.Intel.Decoder.Bitness">
            <summary>
            Gets the bitness (16, 32 or 64)
            </summary>
        </member>
        <member name="M:Iced.Intel.Decoder.Create(System.Int32,Iced.Intel.CodeReader,Iced.Intel.DecoderOptions)">
            <summary>
            Creates a decoder
            </summary>
            <param name="bitness">16, 32 or 64</param>
            <param name="reader">Code reader</param>
            <param name="options">Decoder options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Decoder.Create16(Iced.Intel.CodeReader,Iced.Intel.DecoderOptions)">
            <summary>
            Creates a decoder that decodes 16-bit code
            </summary>
            <param name="reader">Code reader</param>
            <param name="options">Decoder options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Decoder.Create32(Iced.Intel.CodeReader,Iced.Intel.DecoderOptions)">
            <summary>
            Creates a decoder that decodes 32-bit code
            </summary>
            <param name="reader">Code reader</param>
            <param name="options">Decoder options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Decoder.Create64(Iced.Intel.CodeReader,Iced.Intel.DecoderOptions)">
            <summary>
            Creates a decoder that decodes 64-bit code
            </summary>
            <param name="reader">Code reader</param>
            <param name="options">Decoder options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Decoder.Decode">
            <summary>
            Decodes the next instruction, see also <see cref="M:Iced.Intel.Decoder.Decode(Iced.Intel.Instruction@)"/> which is faster
            if you already have an <see cref="T:Iced.Intel.Instruction"/> local, array element or field.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Decoder.Decode(Iced.Intel.Instruction@)">
            <summary>
            Decodes the next instruction
            </summary>
            <param name="instruction">Decoded instruction</param>
        </member>
        <member name="M:Iced.Intel.Decoder.GetConstantOffsets(Iced.Intel.Instruction@)">
            <summary>
            Gets the offsets of the constants (memory displacement and immediate) in the decoded instruction.
            The caller can check if there are any relocations at those addresses.
            </summary>
            <param name="instruction">The latest instruction that was decoded by this decoder</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Decoder.CreateEncoder(Iced.Intel.CodeWriter)">
            <summary>
            Creates an encoder
            </summary>
            <param name="writer">Destination</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.DecoderOptions">
            <summary>
            Decoder options
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.None">
            <summary>
            No option is enabled
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.NoInvalidCheck">
            <summary>
            Disable some checks for invalid encodings of instructions, eg. most instructions can't
            use a LOCK prefix so if one is found, they're decoded as <see cref="F:Iced.Intel.Code.INVALID"/>
            unless this option is enabled.
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.AmdBranches">
            <summary>
            AMD branch decoder: allow 16-bit branch/ret instructions in 64-bit mode
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.AMD">
            <summary>
            AMD branch decoder: allow 16-bit branch/ret instructions in 64-bit mode
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.ForceReservedNop">
            <summary>
            Decode opcodes 0F0D and 0F18-0F1F as reserved-nop instructions (eg. <see cref="F:Iced.Intel.Code.ReservedNop_rm32_r32_0F1D"/>)
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.Umov">
            <summary>
            Decode umov instructions (eg. <see cref="F:Iced.Intel.Code.Umov_r32_rm32"/>)
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.Xbts">
            <summary>
            Decode xbts/ibts
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.Cmpxchg486A">
            <summary>
            Decode 0FA6/0FA7 as cmpxchg
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.OldFpu">
            <summary>
            Decode some old removed FPU instructions (eg. frstpm)
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.Pcommit">
            <summary>
            Decode <see cref="F:Iced.Intel.Code.Pcommit"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.Loadall286">
            <summary>
            Decode 286 loadall (0F04 and 0F05)
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.Loadall386">
            <summary>
            Decode <see cref="F:Iced.Intel.Code.Loadall386"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.Cl1invmb">
            <summary>
            Decode <see cref="F:Iced.Intel.Code.Cl1invmb"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.MovTr">
            <summary>
            Decode <see cref="F:Iced.Intel.Code.Mov_r32_tr"/> and <see cref="F:Iced.Intel.Code.Mov_tr_r32"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.Jmpe">
            <summary>
            Decode jmpe instructions
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.NoPause">
            <summary>
            Don't decode <see cref="F:Iced.Intel.Code.Pause"/>, decode <see cref="F:Iced.Intel.Code.Nopd"/>/etc instead
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.NoWbnoinvd">
            <summary>
            Don't decode <see cref="F:Iced.Intel.Code.Wbnoinvd"/>, decode <see cref="F:Iced.Intel.Code.Wbinvd"/> instead
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.NoLockMovCR0">
            <summary>
            Don't decode LOCK MOV CR0 as MOV CR8 (AMD)
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.NoMPFX_0FBC">
            <summary>
            Don't decode <see cref="F:Iced.Intel.Code.Tzcnt_r32_rm32"/>/etc, decode <see cref="F:Iced.Intel.Code.Bsf_r32_rm32"/>/etc instead
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.NoMPFX_0FBD">
            <summary>
            Don't decode <see cref="F:Iced.Intel.Code.Lzcnt_r32_rm32"/>/etc, decode <see cref="F:Iced.Intel.Code.Bsr_r32_rm32"/>/etc instead
            </summary>
        </member>
        <member name="F:Iced.Intel.DecoderOptions.NoLahfSahf64">
            <summary>
            Don't decode <see cref="F:Iced.Intel.Code.Lahf"/> and <see cref="F:Iced.Intel.Code.Sahf"/> in 64-bit mode
            </summary>
        </member>
        <member name="M:Iced.Intel.EncoderInternal.Op.GetImmediateOpKind">
            <summary>
            If this is an immediate operand, it returns the <see cref="T:Iced.Intel.OpKind"/> value, else it returns -1
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.EncoderInternal.Op.GetNearBranchOpKind">
            <summary>
            If this is a near branch operand, it returns the <see cref="T:Iced.Intel.OpKind"/> value, else it returns -1
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.EncoderInternal.Op.GetFarBranchOpKind">
            <summary>
            If this is a far branch operand, it returns the <see cref="T:Iced.Intel.OpKind"/> value, else it returns -1
            </summary>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.Encoder">
            <summary>
            Encodes instructions decoded by the decoder or instructions created by other code
            </summary>
        </member>
        <member name="P:Iced.Intel.Encoder.PreventVEX2">
            <summary>
            Disables 2-byte VEX encoding and encodes all VEX instructions with the 3-byte VEX encoding
            </summary>
        </member>
        <member name="P:Iced.Intel.Encoder.VEX_WIG">
            <summary>
            Value of the VEX.W bit to use if it's an instruction that ignores the bit. Default is 0.
            </summary>
        </member>
        <member name="P:Iced.Intel.Encoder.VEX_LIG">
            <summary>
            Value of the VEX.L bit to use if it's an instruction that ignores the bit. Default is 0.
            </summary>
        </member>
        <member name="P:Iced.Intel.Encoder.EVEX_WIG">
            <summary>
            Value of the EVEX.W bit to use if it's an instruction that ignores the bit. Default is 0.
            </summary>
        </member>
        <member name="P:Iced.Intel.Encoder.EVEX_LIG">
            <summary>
            Value of the EVEX.L'L bits to use if it's an instruction that ignores the bits. Default is 0.
            </summary>
        </member>
        <member name="P:Iced.Intel.Encoder.Bitness">
            <summary>
            Gets the bitness (16, 32 or 64)
            </summary>
        </member>
        <member name="M:Iced.Intel.Encoder.Create(System.Int32,Iced.Intel.CodeWriter)">
            <summary>
            Creates an encoder
            </summary>
            <param name="bitness">16, 32 or 64</param>
            <param name="writer">Destination</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Encoder.Create16(Iced.Intel.CodeWriter)">
            <summary>
            Creates a 16-bit encoder
            </summary>
            <param name="writer">Destination</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Encoder.Create32(Iced.Intel.CodeWriter)">
            <summary>
            Creates a 32-bit encoder
            </summary>
            <param name="writer">Destination</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Encoder.Create64(Iced.Intel.CodeWriter)">
            <summary>
            Creates a 64-bit encoder
            </summary>
            <param name="writer">Destination</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Encoder.Encode(Iced.Intel.Instruction@,System.UInt64)">
            <summary>
            Encodes an instruction and returns the size of the encoded instruction.
            A <see cref="T:Iced.Intel.EncoderException"/> is thrown if it failed to encode the instruction.
            </summary>
            <param name="instruction">Instruction to encode</param>
            <param name="rip">RIP of the encoded instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Encoder.TryEncode(Iced.Intel.Instruction@,System.UInt64,System.UInt32@,System.String@)">
            <summary>
            Encodes an instruction
            </summary>
            <param name="instruction">Instruction to encode</param>
            <param name="rip">RIP of the encoded instruction</param>
            <param name="encodedLength">Updated with length of encoded instruction if successful</param>
            <param name="errorMessage">Set to the error message if we couldn't encode the instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Encoder.GetConstantOffsets">
            <summary>
            Gets the offsets of the constants (memory displacement and immediate) in the encoded instruction.
            The caller can use this information to add relocations if needed.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.EncoderCodeExtensions">
            <summary>
            Extensions
            </summary>
        </member>
        <member name="M:Iced.Intel.EncoderCodeExtensions.ToOpCode(Iced.Intel.Code)">
            <summary>
            Gets a <see cref="T:Iced.Intel.OpCodeInfo"/>
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.EncoderException">
            <summary>
            Thrown if the encoder can't encode an instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.EncoderException.Instruction">
            <summary>
            The instruction that couldn't be encoded
            </summary>
        </member>
        <member name="M:Iced.Intel.EncoderException.#ctor(System.String,Iced.Intel.Instruction@)">
            <summary>
            Constructor
            </summary>
            <param name="message">Exception message</param>
            <param name="instruction">Instruction</param>
        </member>
        <member name="M:Iced.Intel.EncoderException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Iced.Intel.EncodingKind">
            <summary>
            Instruction encoding
            </summary>
        </member>
        <member name="F:Iced.Intel.EncodingKind.Legacy">
            <summary>
            Legacy encoding
            </summary>
        </member>
        <member name="F:Iced.Intel.EncodingKind.VEX">
            <summary>
            VEX encoding
            </summary>
        </member>
        <member name="F:Iced.Intel.EncodingKind.EVEX">
            <summary>
            EVEX encoding
            </summary>
        </member>
        <member name="F:Iced.Intel.EncodingKind.XOP">
            <summary>
            XOP encoding
            </summary>
        </member>
        <member name="F:Iced.Intel.EncodingKind.D3NOW">
            <summary>
            3DNow! encoding
            </summary>
        </member>
        <member name="T:Iced.Intel.FlowControl">
            <summary>
            Flow control
            </summary>
        </member>
        <member name="F:Iced.Intel.FlowControl.Next">
            <summary>
            The next instruction that will be executed is the next instruction in the instruction stream
            </summary>
        </member>
        <member name="F:Iced.Intel.FlowControl.UnconditionalBranch">
            <summary>
            It's an unconditional branch instruction: jmp near, jmp far
            </summary>
        </member>
        <member name="F:Iced.Intel.FlowControl.IndirectBranch">
            <summary>
            It's an unconditional indirect branch: jmp near reg, jmp near [mem], jmp far [mem]
            </summary>
        </member>
        <member name="F:Iced.Intel.FlowControl.ConditionalBranch">
            <summary>
            It's a conditional branch instruction: jcc short, jcc near, loop, loopcc, jrcxz
            </summary>
        </member>
        <member name="F:Iced.Intel.FlowControl.Return">
            <summary>
            It's a return instruction: ret near, ret far, iret, sysret, sysexit, rsm, vmlaunch, vmresume, vmrun, skinit
            </summary>
        </member>
        <member name="F:Iced.Intel.FlowControl.Call">
            <summary>
            It's a call instruction: call near, call far, syscall, sysenter, vmcall, vmmcall
            </summary>
        </member>
        <member name="F:Iced.Intel.FlowControl.IndirectCall">
            <summary>
            It's an indirect call instruction: call near reg, call near [mem], call far [mem]
            </summary>
        </member>
        <member name="F:Iced.Intel.FlowControl.Interrupt">
            <summary>
            It's an interrupt instruction: int n, int3, int1, into
            </summary>
        </member>
        <member name="F:Iced.Intel.FlowControl.XbeginXabortXend">
            <summary>
            It's xbegin, xabort or xend
            </summary>
        </member>
        <member name="F:Iced.Intel.FlowControl.Exception">
            <summary>
            It's an invalid instruction, eg. <see cref="F:Iced.Intel.Code.INVALID"/>, ud0, ud1, ud2
            </summary>
        </member>
        <member name="T:Iced.Intel.Formatter">
            <summary>
            Formats instructions
            </summary>
        </member>
        <member name="P:Iced.Intel.Formatter.Options">
            <summary>
            Gets the formatter options
            </summary>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatMnemonic(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats the mnemonic and any prefixes
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatMnemonic(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput,Iced.Intel.FormatMnemonicOptions)">
            <summary>
            Formats the mnemonic and any prefixes
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
            <param name="options">Options</param>
        </member>
        <member name="M:Iced.Intel.Formatter.GetOperandCount(Iced.Intel.Instruction@)">
            <summary>
            Gets the number of operands that will be formatted. A formatter can add and remove operands
            </summary>
            <param name="instruction">Instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.TryGetOpAccess(Iced.Intel.Instruction@,System.Int32,Iced.Intel.OpAccess@)">
            <summary>
            Returns the operand access but only if it's an operand added by the formatter. If it's an
            operand that is part of <see cref="T:Iced.Intel.Instruction"/>, you should call eg.
            <see cref="M:Iced.Intel.Instruction.GetInfo"/> or <see cref="M:Iced.Intel.InstructionInfoFactory.GetInfo(Iced.Intel.Instruction@)"/>.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.Formatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
            <param name="access">Updated with operand access if successful</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.GetInstructionOperand(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Converts a formatter operand index to an instruction operand index. Returns -1 if it's an operand added by the formatter
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.Formatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.GetFormatterOperand(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Converts an instruction operand index to a formatter operand index. Returns -1 if the instruction operand isn't used by the formatter
            </summary>
            <param name="instruction">Instruction</param>
            <param name="instructionOperand">Instruction operand</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatOperand(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput,System.Int32)">
            <summary>
            Formats an operand. This is a formatter operand and not necessarily a real instruction operand.
            A formatter can add and remove operands.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.Formatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatOperandSeparator(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats an operand separator
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatAllOperands(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats all operands
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.Formatter.Format(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats the whole instruction: prefixes, mnemonic, operands
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.Formatter.Format(Iced.Intel.Register)">
            <summary>
            Formats a register
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatInt8(System.SByte)">
            <summary>
            Formats a <see cref="T:System.SByte"/>
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatInt16(System.Int16)">
            <summary>
            Formats a <see cref="T:System.Int16"/>
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatInt32(System.Int32)">
            <summary>
            Formats a <see cref="T:System.Int32"/>
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatInt64(System.Int64)">
            <summary>
            Formats a <see cref="T:System.Int64"/>
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatUInt8(System.Byte)">
            <summary>
            Formats a <see cref="T:System.Byte"/>
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatUInt16(System.UInt16)">
            <summary>
            Formats a <see cref="T:System.UInt16"/>
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatUInt32(System.UInt32)">
            <summary>
            Formats a <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatUInt64(System.UInt64)">
            <summary>
            Formats a <see cref="T:System.UInt64"/>
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatInt8(System.SByte,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.SByte"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatInt16(System.Int16,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int16"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatInt32(System.Int32,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int32"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatInt64(System.Int64,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int64"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatUInt8(System.Byte,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Byte"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatUInt16(System.UInt16,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt16"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatUInt32(System.UInt32,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Formatter.FormatUInt64(System.UInt64,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt64"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.FormatMnemonicOptions">
            <summary>
            Options used by <see cref="M:Iced.Intel.Formatter.FormatMnemonic(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatMnemonicOptions.None">
            <summary>
            No option is set
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatMnemonicOptions.NoPrefixes">
            <summary>
            Don't add any prefixes
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatMnemonicOptions.NoMnemonic">
            <summary>
            Don't add the mnemonic
            </summary>
        </member>
        <member name="T:Iced.Intel.FormatterOptions">
            <summary>
            Formatter options
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.UpperCasePrefixes">
            <summary>
            Prefixes are upper cased
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.UpperCaseMnemonics">
            <summary>
            Mnemonics are upper cased
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.UpperCaseRegisters">
            <summary>
            Registers are upper cased
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.UpperCaseKeywords">
            <summary>
            Keywords are upper cased (eg. BYTE PTR, SHORT)
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.UpperCaseOther">
            <summary>
            Upper case decorators, eg. {z}, {sae}, {rd-sae}
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.UpperCaseDecorators">
            <summary>
            Upper case decorators, eg. {z}, {sae}, {rd-sae}
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.UpperCaseAll">
            <summary>
            Everything is upper cased, except numbers and their prefixes/suffixes
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.FirstOperandCharIndex">
            <summary>
            Character index (0-based) where the first operand is formatted. Can be set to 0 to format it immediately after the mnemonic.
            At least one space or tab is always added betewen the mnemonic and the first operand.
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.TabSize">
            <summary>
            Size of a tab character or &lt;= 0 to use spaces
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.SpaceAfterOperandSeparator">
            <summary>
            Add a space after the operand separator, eg. "rax, rcx" vs "rax,rcx"
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.SpaceAfterMemoryBracket">
            <summary>
            Add a space between the memory expression and the brackets, eg. "[ rax ]" vs "[rax]"
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.SpaceBetweenMemoryAddOperators">
            <summary>
            Add spaces between memory operand "+" and "-" operators, eg. "[rax + rcx]" vs "[rax+rcx]"
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.SpaceBetweenMemoryMulOperators">
            <summary>
            Add spaces between memory operand "*" operator, eg. "[rax * 4]" vs "[rax*4]"
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.ScaleBeforeIndex">
            <summary>
            Show memory operand scale value before the index register, eg. "[4*rax]" vs "[rax*4]"
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.AlwaysShowScale">
            <summary>
            Always show the scale value even if it's *1, eg. "[rax+rcx*1]" vs "[rax+rcx]"
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.AlwaysShowSegmentRegister">
            <summary>
            Always show the effective segment register. If the option is false, only show the segment register if
            there's a segment override prefix. Eg. "ds:[rax]" vs "[rax]"
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.ShowZeroDisplacements">
            <summary>
            Show zero displacements, eg. '[rcx*2+0]' vs '[rcx*2]'
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.HexPrefix">
            <summary>
            Hex number prefix or null/empty string, eg. "0x"
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.HexSuffix">
            <summary>
            Hex number suffix or null/empty string, eg. "h"
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.HexDigitGroupSize">
            <summary>
            Size of a digit group
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.DecimalPrefix">
            <summary>
            Decimal number prefix or null/empty string
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.DecimalSuffix">
            <summary>
            Decimal number suffix or null/empty string
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.DecimalDigitGroupSize">
            <summary>
            Size of a digit group
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.OctalPrefix">
            <summary>
            Octal number prefix or null/empty string
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.OctalSuffix">
            <summary>
            Octal number suffix or null/empty string
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.OctalDigitGroupSize">
            <summary>
            Size of a digit group
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.BinaryPrefix">
            <summary>
            Binary number prefix or null/empty string
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.BinarySuffix">
            <summary>
            Binary number suffix or null/empty string
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.BinaryDigitGroupSize">
            <summary>
            Size of a digit group
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.DigitSeparator">
            <summary>
            Digit separator or null/empty string
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.ShortNumbers">
            <summary>
            Use shortest possible hexadecimal/octal/binary numbers, eg. 0xA/0Ah instead of eg. 0x0000000A/0000000Ah.
            This option has no effect on branch targets, use <see cref="P:Iced.Intel.FormatterOptions.ShortBranchNumbers"/>.
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.LeadingZeroes">
            <summary>
            Add leading zeroes to hexadecimal/octal/binary numbers, eg. 0x0000000A/0000000Ah vs 0xA/0Ah.
            This option has no effect on branch targets, use <see cref="P:Iced.Intel.FormatterOptions.BranchLeadingZeroes"/>.
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.UpperCaseHex">
            <summary>
            Use upper case hex digits
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.SmallHexNumbersInDecimal">
            <summary>
            Small hex numbers (-9 .. 9) are shown in decimal
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.AddLeadingZeroToHexNumbers">
            <summary>
            Add a leading zero to numbers if there's no prefix and the number starts with hex digits A-F, eg. Ah vs 0Ah
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.NumberBase">
            <summary>
            Number base
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.ShortBranchNumbers">
            <summary>
            Don't add leading zeroes to branch offsets, eg. 'je 123h' vs 'je 00000123h'. Used by call near, call far, jmp near, jmp far, jcc, loop, loopcc, xbegin
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.BranchLeadingZeroes">
            <summary>
            Add leading zeroes to branch offsets, eg. 'je 00000123h' vs 'je 123h'. Used by call near, call far, jmp near, jmp far, jcc, loop, loopcc, xbegin
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.SignedImmediateOperands">
            <summary>
            Show immediate operands as signed numbers, eg. 'mov eax,FFFFFFFF' vs 'mov eax,-1'
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.SignedMemoryDisplacements">
            <summary>
            Displacements are signed numbers, eg. 'mov al,[eax-2000h]' vs 'mov al,[eax+0FFFFE000h]'
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.SignExtendMemoryDisplacements">
            <summary>
            Sign extend memory displacements to the address size (16-bit, 32-bit, 64-bit), eg. 'mov al,[eax+12h]' vs 'mov al,[eax+00000012h]'
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.MemorySizeOptions">
            <summary>
            Options that control if the memory size (eg. dword ptr) is shown or not.
            This is ignored by the GAS (AT&amp;T) formatter.
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.RipRelativeAddresses">
            <summary>
            true to show RIP relative addresses as '[rip+12345678h]', false to show RIP relative addresses as '[1029384756AFBECDh]'
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.ShowBranchSize">
            <summary>
            Shows near, short, etc if it's a branch instruction, eg. 'je short 1234h' vs 'je 1234h'
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.UsePseudoOps">
            <summary>
            Use pseudo instructions, eg. vcmpngesd vs vcmpsd+imm8
            </summary>
        </member>
        <member name="P:Iced.Intel.FormatterOptions.ShowSymbolAddress">
            <summary>
            Show the original value after the symbol name, eg. 'mov eax,[myfield (12345678)]' vs 'mov eax,[myfield]'
            </summary>
        </member>
        <member name="T:Iced.Intel.NumberBase">
            <summary>
            Number base
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberBase.Hexadecimal">
            <summary>
            Hex numbers (base 16)
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberBase.Decimal">
            <summary>
            Decimal numbers (base 10)
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberBase.Octal">
            <summary>
            Octal numbers (base 8)
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberBase.Binary">
            <summary>
            Binary numbers (base 2)
            </summary>
        </member>
        <member name="T:Iced.Intel.MemorySizeOptions">
            <summary>
            Memory size options used by the formatters
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySizeOptions.Default">
            <summary>
            Show memory size if the assembler requires it, else don't show any
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySizeOptions.Always">
            <summary>
            Always show the memory size, even if the assembler doesn't need it
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySizeOptions.Minimum">
            <summary>
            Show memory size if a human can't figure out the size of the operand
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySizeOptions.Never">
            <summary>
            Never show memory size
            </summary>
        </member>
        <member name="T:Iced.Intel.FormatterOutput">
            <summary>
            Used by a <see cref="T:Iced.Intel.Formatter"/> to write all text
            </summary>
        </member>
        <member name="M:Iced.Intel.FormatterOutput.Write(System.String,Iced.Intel.FormatterOutputTextKind)">
            <summary>
            Writes text and text kind
            </summary>
            <param name="text">Text, can be an empty string</param>
            <param name="kind">Text kind. This value can be identical to the previous value passed to this method. It's
            the responsibility of the implementer to merge any such strings if needed.</param>
        </member>
        <member name="M:Iced.Intel.FormatterOutput.WritePrefix(Iced.Intel.Instruction@,System.String,Iced.Intel.PrefixKind)">
            <summary>
            Writes a prefix
            </summary>
            <param name="instruction">Instruction</param>
            <param name="text">Prefix text</param>
            <param name="prefix">Prefix</param>
        </member>
        <member name="M:Iced.Intel.FormatterOutput.WriteMnemonic(Iced.Intel.Instruction@,System.String)">
            <summary>
            Writes a mnemonic (<see cref="P:Iced.Intel.Instruction.Mnemonic"/>)
            </summary>
            <param name="instruction">Instruction</param>
            <param name="text">Mnemonic text</param>
        </member>
        <member name="M:Iced.Intel.FormatterOutput.WriteNumber(Iced.Intel.Instruction@,System.Int32,System.Int32,System.String,System.UInt64,Iced.Intel.NumberKind,Iced.Intel.FormatterOutputTextKind)">
            <summary>
            Writes a number
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.</param>
            <param name="instructionOperand">Instruction operand number, 0-based, or -1 if it's an operand created by the formatter.</param>
            <param name="text">Number text</param>
            <param name="value">Value</param>
            <param name="numberKind">Number kind</param>
            <param name="kind">Text kind</param>
        </member>
        <member name="M:Iced.Intel.FormatterOutput.WriteDecorator(Iced.Intel.Instruction@,System.Int32,System.Int32,System.String,Iced.Intel.DecoratorKind)">
            <summary>
            Writes a decorator
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.</param>
            <param name="instructionOperand">Instruction operand number, 0-based, or -1 if it's an operand created by the formatter.</param>
            <param name="text">Decorator text</param>
            <param name="decorator">Decorator</param>
        </member>
        <member name="M:Iced.Intel.FormatterOutput.WriteRegister(Iced.Intel.Instruction@,System.Int32,System.Int32,System.String,Iced.Intel.Register)">
            <summary>
            Writes a register
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.</param>
            <param name="instructionOperand">Instruction operand number, 0-based, or -1 if it's an operand created by the formatter.</param>
            <param name="text">Register text</param>
            <param name="register">Register</param>
        </member>
        <member name="M:Iced.Intel.FormatterOutput.WriteSymbol(Iced.Intel.Instruction@,System.Int32,System.Int32,System.UInt64,Iced.Intel.SymbolResult@)">
            <summary>
            Writes a symbol
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.</param>
            <param name="instructionOperand">Instruction operand number, 0-based, or -1 if it's an operand created by the formatter.</param>
            <param name="address">Address</param>
            <param name="symbol">Symbol</param>
        </member>
        <member name="T:Iced.Intel.PrefixKind">
            <summary>
            Prefix
            </summary>
        </member>
        <member name="T:Iced.Intel.DecoratorKind">
            <summary>
            Decorator
            </summary>
        </member>
        <member name="T:Iced.Intel.NumberKind">
            <summary>
            Number kind
            </summary>
        </member>
        <member name="T:Iced.Intel.FormatterOutputTextKind">
            <summary>
            Formatter text kind
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Text">
            <summary>
            Normal text
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Directive">
            <summary>
            Assembler directive
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Prefix">
            <summary>
            Any prefix
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Mnemonic">
            <summary>
            Any mnemonic
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Keyword">
            <summary>
            Any keyword
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Operator">
            <summary>
            Any operator
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Punctuation">
            <summary>
            Any punctuation
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Number">
            <summary>
            Number
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Register">
            <summary>
            Any register
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Decorator">
            <summary>
            A decorator, eg. 'sae' in '{sae}'
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.SelectorValue">
            <summary>
            Selector value (eg. far jmp/call)
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.LabelAddress">
            <summary>
            Label address (eg. JE XXXXXX)
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.FunctionAddress">
            <summary>
            Function address (eg. CALL XXXXX)
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Data">
            <summary>
            Data symbol
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Label">
            <summary>
            Label symbol
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOutputTextKind.Function">
            <summary>
            Function symbol
            </summary>
        </member>
        <member name="T:Iced.Intel.GasFormatterOptions">
            <summary>
            GNU assembler (AT&amp;T) formatter options
            </summary>
        </member>
        <member name="P:Iced.Intel.GasFormatterOptions.NakedRegisters">
            <summary>
            If true, the formatter doesn't add '%' to registers, eg. %eax vs eax
            </summary>
        </member>
        <member name="P:Iced.Intel.GasFormatterOptions.ShowMnemonicSizeSuffix">
            <summary>
            Shows the mnemonic size suffix, eg. 'mov %eax,%ecx' vs 'movl %eax,%ecx'
            </summary>
        </member>
        <member name="P:Iced.Intel.GasFormatterOptions.SpaceAfterMemoryOperandComma">
            <summary>
            Add a space after the comma if it's a memory operand, eg. '(%eax,%ecx,2)' vs '(%eax, %ecx, 2)'
            </summary>
        </member>
        <member name="M:Iced.Intel.GasFormatterOptions.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Iced.Intel.GasFormatter">
            <summary>
            GNU assembler (AT&amp;T) formatter
            </summary>
        </member>
        <member name="P:Iced.Intel.GasFormatter.Options">
            <summary>
            Gets the formatter options, see also <see cref="P:Iced.Intel.GasFormatter.GasOptions"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.GasFormatter.GasOptions">
            <summary>
            Gets the GAS formatter options
            </summary>
        </member>
        <member name="M:Iced.Intel.GasFormatter.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Iced.Intel.GasFormatter.#ctor(Iced.Intel.GasFormatterOptions,Iced.Intel.ISymbolResolver,Iced.Intel.IFormatterOptionsProvider)">
            <summary>
            Constructor
            </summary>
            <param name="options">Formatter options or null</param>
            <param name="symbolResolver">Symbol resolver or null</param>
            <param name="optionsProvider">Operand options provider or null</param>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatMnemonic(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput,Iced.Intel.FormatMnemonicOptions)">
            <summary>
            Formats the mnemonic and any prefixes
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
            <param name="options">Options</param>
        </member>
        <member name="M:Iced.Intel.GasFormatter.GetOperandCount(Iced.Intel.Instruction@)">
            <summary>
            Gets the number of operands that will be formatted. A formatter can add and remove operands
            </summary>
            <param name="instruction">Instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.TryGetOpAccess(Iced.Intel.Instruction@,System.Int32,Iced.Intel.OpAccess@)">
            <summary>
            Returns the operand access but only if it's an operand added by the formatter. If it's an
            operand that is part of <see cref="T:Iced.Intel.Instruction"/>, you should call eg.
            <see cref="M:Iced.Intel.Instruction.GetInfo"/> or <see cref="M:Iced.Intel.InstructionInfoFactory.GetInfo(Iced.Intel.Instruction@)"/>.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.GasFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
            <param name="access">Updated with operand access if successful</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.GetInstructionOperand(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Converts a formatter operand index to an instruction operand index. Returns -1 if it's an operand added by the formatter
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.GasFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.GetFormatterOperand(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Converts an instruction operand index to a formatter operand index. Returns -1 if the instruction operand isn't used by the formatter
            </summary>
            <param name="instruction">Instruction</param>
            <param name="instructionOperand">Instruction operand</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatOperand(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput,System.Int32)">
            <summary>
            Formats an operand. This is a formatter operand and not necessarily a real instruction operand.
            A formatter can add and remove operands.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.GasFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatOperandSeparator(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats an operand separator
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatAllOperands(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats all operands
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.GasFormatter.Format(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats the whole instruction: prefixes, mnemonic, operands
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.GasFormatter.Format(Iced.Intel.Register)">
            <summary>
            Formats a register
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatInt8(System.SByte,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.SByte"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatInt16(System.Int16,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int16"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatInt32(System.Int32,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int32"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatInt64(System.Int64,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int64"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatUInt8(System.Byte,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Byte"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatUInt16(System.UInt16,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt16"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatUInt32(System.UInt32,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.GasFormatter.FormatUInt64(System.UInt64,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt64"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.IcedFeatures">
            <summary>
            Gets the available features
            </summary>
        </member>
        <member name="P:Iced.Intel.IcedFeatures.HasGasFormatter">
            <summary>
            true if the gas (AT&amp;T) formatter is available
            </summary>
        </member>
        <member name="P:Iced.Intel.IcedFeatures.HasIntelFormatter">
            <summary>
            true if the Intel (xed) formatter is available
            </summary>
        </member>
        <member name="P:Iced.Intel.IcedFeatures.HasMasmFormatter">
            <summary>
            true if the masm formatter is available
            </summary>
        </member>
        <member name="P:Iced.Intel.IcedFeatures.HasNasmFormatter">
            <summary>
            true if the nasm formatter is available
            </summary>
        </member>
        <member name="P:Iced.Intel.IcedFeatures.HasDecoder">
            <summary>
            true if the decoder is available
            </summary>
        </member>
        <member name="P:Iced.Intel.IcedFeatures.HasDecoder32">
            <summary>
            true if the 16/32-bit decoder is available
            </summary>
        </member>
        <member name="P:Iced.Intel.IcedFeatures.HasDecoder64">
            <summary>
            true if the 64-bit decoder is available
            </summary>
        </member>
        <member name="P:Iced.Intel.IcedFeatures.HasEncoder">
            <summary>
            true if the encoder is available
            </summary>
        </member>
        <member name="P:Iced.Intel.IcedFeatures.HasInstructionInfo">
            <summary>
            true if the instruction info code is available
            </summary>
        </member>
        <member name="M:Iced.Intel.IcedFeatures.Initialize">
            <summary>
            Initializes some static constructors related to the decoder and instruction info. If those
            static constructors are initialized, the jitter generates faster code since it doesn't have
            to add runtime checks to see if those static constructors must be called.
            
            This method should be called before using the decoder and instruction info classes and
            should *not* be called from the same method as any code that uses the decoder / instruction
            info classes. Eg. call this method from Main() and decode instructions / get instruction info
            in a method called by Main().
            </summary>
        </member>
        <member name="T:Iced.Intel.IFormatterOptionsProvider">
            <summary>
            Can override options used by a <see cref="T:Iced.Intel.Formatter"/>
            </summary>
        </member>
        <member name="M:Iced.Intel.IFormatterOptionsProvider.GetOperandOptions(Iced.Intel.Instruction@,System.Int32,System.Int32,Iced.Intel.FormatterOperandOptions@,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Called by the formatter. The method can override any options before the formatter uses them.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.</param>
            <param name="instructionOperand">Instruction operand number, 0-based, or -1 if it's an operand created by the formatter.</param>
            <param name="options">Options. Only those options that will be used by the formatter are initialized.</param>
            <param name="numberOptions">Number formatting options</param>
        </member>
        <member name="T:Iced.Intel.FormatterOperandOptions">
            <summary>
            Operand options
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOperandOptions.None">
            <summary>
            No option is enabled
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOperandOptions.NoBranchSize">
            <summary>
            Don't show branch size (short, near ptr)
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOperandOptions.RipRelativeAddresses">
            <summary>
            If set, show RIP relative addresses as '[rip+12345678h]', else show RIP relative addresses as '[1029384756AFBECDh]'
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOperandOptions.MemorySizeShift">
            <summary>
            Bit position of <see cref="T:Iced.Intel.MemorySizeOptions"/> bits
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOperandOptions.MemorySizeMask">
            <summary>
            MemorySizeXXX mask, use <see cref="M:Iced.Intel.FormatterOperandOptionsExtensions.WithMemorySize(Iced.Intel.FormatterOperandOptions,Iced.Intel.MemorySizeOptions)"/> to change this value
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOperandOptions.MemorySizeDefault">
            <summary>
            Show memory size if the assembler requires it, else don't show any
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOperandOptions.MemorySizeAlways">
            <summary>
            Always show the memory size, even if the assembler doesn't need it
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOperandOptions.MemorySizeMinimum">
            <summary>
            Show memory size if a human can't figure out the size of the operand
            </summary>
        </member>
        <member name="F:Iced.Intel.FormatterOperandOptions.MemorySizeNever">
            <summary>
            Never show memory size
            </summary>
        </member>
        <member name="T:Iced.Intel.FormatterOperandOptionsExtensions">
            <summary>
            Extension methods
            </summary>
        </member>
        <member name="M:Iced.Intel.FormatterOperandOptionsExtensions.WithMemorySize(Iced.Intel.FormatterOperandOptions,Iced.Intel.MemorySizeOptions)">
            <summary>
            Returns new options with a new <see cref="T:Iced.Intel.MemorySizeOptions"/> value
            </summary>
            <param name="self">Operand options</param>
            <param name="options">Memory size options</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.NumberFormattingOptions">
            <summary>
            Gets initialized with the default options and can be overridden by a <see cref="T:Iced.Intel.IFormatterOptionsProvider"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberFormattingOptions.DigitSeparator">
            <summary>
            Digit separator or null/empty string
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberFormattingOptions.Prefix">
            <summary>
            Number prefix or null/empty string
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberFormattingOptions.Suffix">
            <summary>
            Number suffix or null/empty string
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberFormattingOptions.DigitGroupSize">
            <summary>
            Size of a digit group
            </summary>
        </member>
        <member name="P:Iced.Intel.NumberFormattingOptions.NumberBase">
            <summary>
            Number base
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberFormattingOptions.UpperCaseHex">
            <summary>
            Use upper case hex digits
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberFormattingOptions.SmallHexNumbersInDecimal">
            <summary>
            Small hex numbers (-9 .. 9) are shown in decimal
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberFormattingOptions.AddLeadingZeroToHexNumbers">
            <summary>
            Add a leading zero to numbers if there's no prefix and the number begins with hex digits A-F, eg. Ah vs 0Ah
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberFormattingOptions.LeadingZeroes">
            <summary>
            If true, add leading zeroes to numbers, eg. '1h' vs '00000001h'
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberFormattingOptions.SignedNumber">
            <summary>
            If true, the number is signed, and if false it's an unsigned number
            </summary>
        </member>
        <member name="F:Iced.Intel.NumberFormattingOptions.SignExtendImmediate">
            <summary>
            Sign extend the number to the real size (16-bit, 32-bit, 64-bit), eg. 'mov al,[eax+12h]' vs 'mov al,[eax+00000012h]'
            </summary>
        </member>
        <member name="M:Iced.Intel.NumberFormattingOptions.CreateImmediate(Iced.Intel.FormatterOptions)">
            <summary>
            Creates options used when formatting immediate values
            </summary>
            <param name="options">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NumberFormattingOptions.CreateDisplacement(Iced.Intel.FormatterOptions)">
            <summary>
            Creates options used when formatting displacements
            </summary>
            <param name="options">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NumberFormattingOptions.CreateBranch(Iced.Intel.FormatterOptions)">
            <summary>
            Creates options used when formatting branch operands
            </summary>
            <param name="options">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NumberFormattingOptions.#ctor(Iced.Intel.FormatterOptions,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="options">Options</param>
            <param name="leadingZeroes">Add leading zeroes to numbers, eg. '1h' vs '00000001h'</param>
            <param name="signedNumber">Signed numbers if true, and unsigned numbers if false</param>
            <param name="signExtendImmediate">Sign extend the number to the real size (16-bit, 32-bit, 64-bit), eg. 'mov al,[eax+12h]' vs 'mov al,[eax+00000012h]'</param>
        </member>
        <member name="T:Iced.Intel.Instruction">
            <summary>
            A 16/32/64-bit instruction
            </summary>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code)">
            <summary>
            Creates a new <see cref="T:Iced.Intel.Instruction"/> with no operands
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateBranch(Iced.Intel.Code,System.UInt64)">
            <summary>
            Creates a new near/short branch <see cref="T:Iced.Intel.Instruction"/>
            </summary>
            <param name="code">Code value</param>
            <param name="target">Target address</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateBranch(Iced.Intel.Code,System.UInt16,System.UInt32)">
            <summary>
            Creates a new far branch <see cref="T:Iced.Intel.Instruction"/>
            </summary>
            <param name="code">Code value</param>
            <param name="selector">Selector/segment value</param>
            <param name="offset">Offset</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateMemory64(Iced.Intel.Code,Iced.Intel.Register,System.UInt64,Iced.Intel.Register)">
            <summary>
            Creates an instruction with a 64-bit memory offset as the second operand, eg. 'mov al,[123456789ABCDEF0]'
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register (al, ax, eax, rax)</param>
            <param name="address">64-bit address</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateMemory64(Iced.Intel.Code,System.UInt64,Iced.Intel.Register,Iced.Intel.Register)">
            <summary>
            Creates an instruction with a 64-bit memory offset as the first operand, eg. 'mov [123456789ABCDEF0],al'
            </summary>
            <param name="code">Code value</param>
            <param name="address">64-bit address</param>
            <param name="register">Register (al, ax, eax, rax)</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.MemoryOperand@)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="memory">Memory operand</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,System.Int64)">
            <summary>
            Creates an instruction with a 64-bit immediate value
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register</param>
            <param name="immediate">64-bit immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,System.UInt64)">
            <summary>
            Creates an instruction with a 64-bit immediate value
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register</param>
            <param name="immediate">64-bit immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.MemoryOperand@)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register</param>
            <param name="memory">Memory operand</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,System.Int32,Iced.Intel.Register)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="immediate">Immediate</param>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,System.UInt32,Iced.Intel.Register)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="immediate">Immediate</param>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,System.Int32,System.Byte)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="immediate">Immediate</param>
            <param name="immediate2">Second immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,System.UInt32,System.Byte)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="immediate">Immediate</param>
            <param name="immediate2">Second immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.MemoryOperand@,Iced.Intel.Register)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="memory">Memory operand</param>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.MemoryOperand@,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="memory">Memory operand</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.MemoryOperand@,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="memory">Memory operand</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="register3">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.MemoryOperand@)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="memory">Memory operand</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,System.Int32,System.Byte)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register</param>
            <param name="immediate">Immediate</param>
            <param name="immediate2">Second immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,System.UInt32,System.Byte)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register</param>
            <param name="immediate">Immediate</param>
            <param name="immediate2">Second immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.MemoryOperand@,Iced.Intel.Register)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="memory">Memory operand</param>
            <param name="register2">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.MemoryOperand@,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register</param>
            <param name="memory">Memory operand</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.MemoryOperand@,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register">Register</param>
            <param name="memory">Memory operand</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.MemoryOperand@,Iced.Intel.Register,Iced.Intel.Register)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="memory">Memory operand</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.MemoryOperand@,Iced.Intel.Register,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="memory">Memory operand</param>
            <param name="register">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.MemoryOperand@,Iced.Intel.Register,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="memory">Memory operand</param>
            <param name="register">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="register3">Register</param>
            <param name="register4">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="register3">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="register3">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.MemoryOperand@)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="register3">Register</param>
            <param name="memory">Memory operand</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,System.Int32,System.Byte)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="immediate">Immediate</param>
            <param name="immediate2">Second immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,System.UInt32,System.Byte)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="immediate">Immediate</param>
            <param name="immediate2">Second immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.MemoryOperand@,Iced.Intel.Register)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="memory">Memory operand</param>
            <param name="register3">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.MemoryOperand@,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="memory">Memory operand</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.MemoryOperand@,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="memory">Memory operand</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="register3">Register</param>
            <param name="register4">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="register3">Register</param>
            <param name="register4">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.MemoryOperand@,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="register3">Register</param>
            <param name="memory">Memory operand</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.MemoryOperand@,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="register3">Register</param>
            <param name="memory">Memory operand</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.MemoryOperand@,Iced.Intel.Register,System.Int32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="memory">Memory operand</param>
            <param name="register3">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Create(Iced.Intel.Code,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.MemoryOperand@,Iced.Intel.Register,System.UInt32)">
            <summary>
            Creates an instruction
            </summary>
            <param name="code">Code value</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="memory">Memory operand</param>
            <param name="register3">Register</param>
            <param name="immediate">Immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateOutsb(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates an outsb instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateOutsw(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates an outsw instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateOutsd(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates an outsd instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateLodsb(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a lodsb instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateLodsw(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a lodsw instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateLodsd(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a lodsd instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateLodsq(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a lodsq instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateScasb(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a scasb instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateScasw(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a scasw instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateScasd(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a scasd instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateScasq(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a scasq instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateInsb(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a insb instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateInsw(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a insw instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateInsd(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a insd instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateStosb(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a stosb instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateStosw(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a stosw instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateStosd(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a stosd instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateStosq(System.Int32,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a stosq instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateCmpsb(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a cmpsb instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateCmpsw(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a cmpsw instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateCmpsd(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a cmpsd instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateCmpsq(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a cmpsq instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateMovsb(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a movsb instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateMovsw(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a movsw instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateMovsd(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a movsd instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateMovsq(System.Int32,Iced.Intel.Register,Iced.Intel.RepPrefixKind)">
            <summary>
            Creates a movsq instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="repPrefix">Rep prefix</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateMaskmovq(System.Int32,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register)">
            <summary>
            Creates a maskmovq instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateMaskmovdqu(System.Int32,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register)">
            <summary>
            Creates a maskmovdqu instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateVmaskmovdqu(System.Int32,Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register)">
            <summary>
            Creates a vmaskmovdqu instruction
            </summary>
            <param name="addressSize">16, 32, or 64</param>
            <param name="register1">Register</param>
            <param name="register2">Register</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <param name="b6"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <param name="b6"></param>
            <param name="b7"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <param name="b6"></param>
            <param name="b7"></param>
            <param name="b8"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <param name="b6"></param>
            <param name="b7"></param>
            <param name="b8"></param>
            <param name="b9"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <param name="b6"></param>
            <param name="b7"></param>
            <param name="b8"></param>
            <param name="b9"></param>
            <param name="b10"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <param name="b6"></param>
            <param name="b7"></param>
            <param name="b8"></param>
            <param name="b9"></param>
            <param name="b10"></param>
            <param name="b11"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <param name="b6"></param>
            <param name="b7"></param>
            <param name="b8"></param>
            <param name="b9"></param>
            <param name="b10"></param>
            <param name="b11"></param>
            <param name="b12"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <param name="b6"></param>
            <param name="b7"></param>
            <param name="b8"></param>
            <param name="b9"></param>
            <param name="b10"></param>
            <param name="b11"></param>
            <param name="b12"></param>
            <param name="b13"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <param name="b6"></param>
            <param name="b7"></param>
            <param name="b8"></param>
            <param name="b9"></param>
            <param name="b10"></param>
            <param name="b11"></param>
            <param name="b12"></param>
            <param name="b13"></param>
            <param name="b14"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="b3"></param>
            <param name="b4"></param>
            <param name="b5"></param>
            <param name="b6"></param>
            <param name="b7"></param>
            <param name="b8"></param>
            <param name="b9"></param>
            <param name="b10"></param>
            <param name="b11"></param>
            <param name="b12"></param>
            <param name="b13"></param>
            <param name="b14"></param>
            <param name="b15"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte[])">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareByte(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a 'db' asm directive
            </summary>
            <param name="data">Data</param>
            <param name="index">Start index</param>
            <param name="length">Number of bytes</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.UInt16)">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="w0"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.UInt16,System.UInt16)">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="w0"></param>
            <param name="w1"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="w0"></param>
            <param name="w1"></param>
            <param name="w2"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="w0"></param>
            <param name="w1"></param>
            <param name="w2"></param>
            <param name="w3"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="w0"></param>
            <param name="w1"></param>
            <param name="w2"></param>
            <param name="w3"></param>
            <param name="w4"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="w0"></param>
            <param name="w1"></param>
            <param name="w2"></param>
            <param name="w3"></param>
            <param name="w4"></param>
            <param name="w5"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="w0"></param>
            <param name="w1"></param>
            <param name="w2"></param>
            <param name="w3"></param>
            <param name="w4"></param>
            <param name="w5"></param>
            <param name="w6"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="w0"></param>
            <param name="w1"></param>
            <param name="w2"></param>
            <param name="w3"></param>
            <param name="w4"></param>
            <param name="w5"></param>
            <param name="w6"></param>
            <param name="w7"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.Byte[])">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="data">Data</param>
            <param name="index">Start index</param>
            <param name="length">Number of bytes</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.UInt16[])">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareWord(System.UInt16[],System.Int32,System.Int32)">
            <summary>
            Create a 'dw' asm directive
            </summary>
            <param name="data">Data</param>
            <param name="index">Start index</param>
            <param name="length">Number of elements</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareDword(System.UInt32)">
            <summary>
            Create a 'dd' asm directive
            </summary>
            <param name="d0"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareDword(System.UInt32,System.UInt32)">
            <summary>
            Create a 'dd' asm directive
            </summary>
            <param name="d0"></param>
            <param name="d1"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareDword(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Create a 'dd' asm directive
            </summary>
            <param name="d0"></param>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareDword(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Create a 'dd' asm directive
            </summary>
            <param name="d0"></param>
            <param name="d1"></param>
            <param name="d2"></param>
            <param name="d3"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareDword(System.Byte[])">
            <summary>
            Create a 'dd' asm directive
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareDword(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a 'dd' asm directive
            </summary>
            <param name="data">Data</param>
            <param name="index">Start index</param>
            <param name="length">Number of bytes</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareDword(System.UInt32[])">
            <summary>
            Create a 'dd' asm directive
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareDword(System.UInt32[],System.Int32,System.Int32)">
            <summary>
            Create a 'dd' asm directive
            </summary>
            <param name="data">Data</param>
            <param name="index">Start index</param>
            <param name="length">Number of elements</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareQword(System.UInt64)">
            <summary>
            Create a 'dq' asm directive
            </summary>
            <param name="q0"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareQword(System.UInt64,System.UInt64)">
            <summary>
            Create a 'dq' asm directive
            </summary>
            <param name="q0"></param>
            <param name="q1"></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareQword(System.Byte[])">
            <summary>
            Create a 'dq' asm directive
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareQword(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a 'dq' asm directive
            </summary>
            <param name="data">Data</param>
            <param name="index">Start index</param>
            <param name="length">Number of bytes</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareQword(System.UInt64[])">
            <summary>
            Create a 'dq' asm directive
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.CreateDeclareQword(System.UInt64[],System.Int32,System.Int32)">
            <summary>
            Create a 'dq' asm directive
            </summary>
            <param name="data">Data</param>
            <param name="index">Start index</param>
            <param name="length">Number of elements</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.Instruction.MemoryFlags">
            <summary>
            [1:0]	= Scale
            [4:2]	= Size of displacement: 0, 1, 2, 4, 8
            [7:5]	= Segment register prefix: none, es, cs, ss, ds, fs, gs, reserved
            [14:8]	= Not used
            [15]	= Broadcasted memory
            </summary>
        </member>
        <member name="T:Iced.Intel.Instruction.OpKindFlags">
            <summary>
            [4:0]	= Operand #0's <see cref="T:Iced.Intel.OpKind"/>
            [9:5]	= Operand #1's <see cref="T:Iced.Intel.OpKind"/>
            [14:10]	= Operand #2's <see cref="T:Iced.Intel.OpKind"/>
            [19:15]	= Operand #3's <see cref="T:Iced.Intel.OpKind"/>
            [23:20]	= db/dw/dd/dq element count (1-16, 1-8, 1-4, or 1-2)
            [29:24]	= Not used
            [31:30]	= CodeSize
            </summary>
        </member>
        <member name="T:Iced.Intel.Instruction.CodeFlags">
            <summary>
            [12:0]	= <see cref="T:Iced.Intel.Code"/>
            [15:13]	= <see cref="T:Iced.Intel.RoundingControl"/>
            [18:16]	= Opmask register or 0 if none
            [22:19]	= Instruction length
            [24:23]	= Not used
            [25]	= Suppress all exceptions
            [26]	= Zeroing masking
            [27]	= xacquire prefix
            [28]	= xrelease prefix
            [29]	= repe prefix
            [30]	= repne prefix
            [31]	= lock prefix
            </summary>
        </member>
        <member name="M:Iced.Intel.Instruction.Equals(Iced.Intel.Instruction@)">
            <summary>
            Checks if this instance equals <paramref name="other"/>
            </summary>
            <param name="other">Other instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.GetHashCode">
            <summary>
            Gets the hash code
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.Equals(System.Object)">
            <summary>
            Checks if this instance equals <paramref name="obj"/>
            </summary>
            <param name="obj">Other instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.EqualsAllBits(Iced.Intel.Instruction@,Iced.Intel.Instruction@)">
            <summary>
            Checks if two instructions are equal, comparing all bits, not ignoring anything
            </summary>
            <param name="a">Instruction #1</param>
            <param name="b">Instruction #2</param>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IP16">
            <summary>
            16-bit IP of the instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IP32">
            <summary>
            32-bit IP of the instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IP64">
            <summary>
            64-bit IP of the instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IP">
            <summary>
            64-bit IP of the instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.NextIP16">
            <summary>
            16-bit IP of the next instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.NextIP32">
            <summary>
            32-bit IP of the next instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.NextIP64">
            <summary>
            64-bit IP of the next instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.NextIP">
            <summary>
            64-bit IP of the next instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.CodeSize">
            <summary>
            Gets the code size when the instruction was decoded. This value is informational and can
            be used by a formatter.
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Code">
            <summary>
            Instruction code
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Mnemonic">
            <summary>
            Gets the mnemonic
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.OpCount">
            <summary>
            Gets the operand count. Up to 5 operands is allowed.
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.ByteLength">
            <summary>
            Gets the length of the instruction, 0-15 bytes. This is just informational. If you modify the instruction
            or create a new one, this property could return the wrong value.
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.HasXacquirePrefix">
            <summary>
            Checks if the instruction has the XACQUIRE prefix (F2)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.HasXreleasePrefix">
            <summary>
            Checks if the instruction has the XACQUIRE prefix (F3)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.HasRepPrefix">
            <summary>
            Checks if the instruction has the REPE or REP prefix (F3)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.HasRepePrefix">
            <summary>
            Checks if the instruction has the REPE or REP prefix (F3)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.HasRepnePrefix">
            <summary>
            Checks if the instruction has the REPNE prefix (F2)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.HasLockPrefix">
            <summary>
            Checks if the instruction has the LOCK prefix (F0)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Op0Kind">
            <summary>
            Gets operand #0's kind if the operand exists (see <see cref="P:Iced.Intel.Instruction.OpCount"/>)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Op1Kind">
            <summary>
            Gets operand #1's kind if the operand exists (see <see cref="P:Iced.Intel.Instruction.OpCount"/>)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Op2Kind">
            <summary>
            Gets operand #2's kind if the operand exists (see <see cref="P:Iced.Intel.Instruction.OpCount"/>)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Op3Kind">
            <summary>
            Gets operand #3's kind if the operand exists (see <see cref="P:Iced.Intel.Instruction.OpCount"/>)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Op4Kind">
            <summary>
            Gets operand #4's kind if the operand exists (see <see cref="P:Iced.Intel.Instruction.OpCount"/>)
            </summary>
        </member>
        <member name="M:Iced.Intel.Instruction.GetOpKind(System.Int32)">
            <summary>
            Gets an operand's kind if it exists (see <see cref="P:Iced.Intel.Instruction.OpCount"/>)
            </summary>
            <param name="operand">Operand number, 0-4</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.SetOpKind(System.Int32,Iced.Intel.OpKind)">
            <summary>
            Sets an operand's kind
            </summary>
            <param name="operand">Operand number, 0-4</param>
            <param name="opKind">Operand kind</param>
        </member>
        <member name="P:Iced.Intel.Instruction.SegmentPrefix">
            <summary>
            Gets the segment override prefix or <see cref="F:Iced.Intel.Register.None"/> if none. See also <see cref="P:Iced.Intel.Instruction.MemorySegment"/>.
            Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Memory"/>, <see cref="F:Iced.Intel.OpKind.Memory64"/>,
            <see cref="F:Iced.Intel.OpKind.MemorySegSI"/>, <see cref="F:Iced.Intel.OpKind.MemorySegESI"/>, <see cref="F:Iced.Intel.OpKind.MemorySegRSI"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.MemorySegment">
            <summary>
            Gets the effective segment register used to reference the memory location.
            Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Memory"/>, <see cref="F:Iced.Intel.OpKind.Memory64"/>,
            <see cref="F:Iced.Intel.OpKind.MemorySegSI"/>, <see cref="F:Iced.Intel.OpKind.MemorySegESI"/>, <see cref="F:Iced.Intel.OpKind.MemorySegRSI"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.MemoryDisplSize">
            <summary>
            Gets the size of the memory displacement in bytes. Valid values are 0, 1 (16/32/64-bit), 2 (16-bit), 4 (32-bit), 8 (64-bit).
            Note that the return value can be 1 and <see cref="P:Iced.Intel.Instruction.MemoryDisplacement"/> may still not fit in
            a signed byte if it's an EVEX encoded instruction.
            Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Memory"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IsBroadcast">
            <summary>
            true if the data is broadcasted (EVEX instructions only)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.MemorySize">
            <summary>
            Gets the size of the memory location that is referenced by the operand. See also <see cref="P:Iced.Intel.Instruction.IsBroadcast"/>.
            Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Memory"/>, <see cref="F:Iced.Intel.OpKind.Memory64"/>,
            <see cref="F:Iced.Intel.OpKind.MemorySegSI"/>, <see cref="F:Iced.Intel.OpKind.MemorySegESI"/>, <see cref="F:Iced.Intel.OpKind.MemorySegRSI"/>,
            <see cref="F:Iced.Intel.OpKind.MemoryESDI"/>, <see cref="F:Iced.Intel.OpKind.MemoryESEDI"/>, <see cref="F:Iced.Intel.OpKind.MemoryESRDI"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.MemoryIndexScale">
            <summary>
            Gets the index register scale value, valid values are *1, *2, *4, *8. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Memory"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.MemoryDisplacement">
            <summary>
            Gets the memory operand's displacement. This should be sign extended to 64 bits if it's 64-bit addressing.
            Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Memory"/>
            </summary>
        </member>
        <member name="M:Iced.Intel.Instruction.GetImmediate(System.Int32)">
            <summary>
            Gets an operand's immediate value
            </summary>
            <param name="operand">Operand number, 0-4</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.SetImmediate(System.Int32,System.Int32)">
            <summary>
            Sets an operand's immediate value
            </summary>
            <param name="operand">Operand number, 0-4</param>
            <param name="immediate">New immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.SetImmediate(System.Int32,System.UInt32)">
            <summary>
            Sets an operand's immediate value
            </summary>
            <param name="operand">Operand number, 0-4</param>
            <param name="immediate">New immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.SetImmediate(System.Int32,System.Int64)">
            <summary>
            Sets an operand's immediate value
            </summary>
            <param name="operand">Operand number, 0-4</param>
            <param name="immediate">New immediate</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.SetImmediate(System.Int32,System.UInt64)">
            <summary>
            Sets an operand's immediate value
            </summary>
            <param name="operand">Operand number, 0-4</param>
            <param name="immediate">New immediate</param>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.Immediate8">
            <summary>
            Gets the operand's immediate value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Immediate8"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Immediate8_2nd">
            <summary>
            Gets the operand's immediate value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Immediate8_2nd"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Immediate16">
            <summary>
            Gets the operand's immediate value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Immediate16"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Immediate32">
            <summary>
            Gets the operand's immediate value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Immediate32"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Immediate64">
            <summary>
            Gets the operand's immediate value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Immediate64"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Immediate8to16">
            <summary>
            Gets the operand's immediate value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Immediate8to16"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Immediate8to32">
            <summary>
            Gets the operand's immediate value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Immediate8to32"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Immediate8to64">
            <summary>
            Gets the operand's immediate value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Immediate8to64"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Immediate32to64">
            <summary>
            Gets the operand's immediate value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Immediate32to64"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.MemoryAddress64">
            <summary>
            Gets the operand's 64-bit address value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Memory64"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.NearBranch16">
            <summary>
            Gets the operand's branch target. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.NearBranch16"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.NearBranch32">
            <summary>
            Gets the operand's branch target. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.NearBranch32"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.NearBranch64">
            <summary>
            Gets the operand's branch target. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.NearBranch64"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.NearBranchTarget">
            <summary>
            Gets the near branch target if it's a call/jmp near branch instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.FarBranch16">
            <summary>
            Gets the operand's branch target. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.FarBranch16"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.FarBranch32">
            <summary>
            Gets the operand's branch target. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.FarBranch32"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.FarBranchSelector">
            <summary>
            Gets the operand's branch target selector. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.FarBranch16"/> or <see cref="F:Iced.Intel.OpKind.FarBranch32"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.MemoryBase">
            <summary>
            Gets the memory operand's base register or <see cref="F:Iced.Intel.Register.None"/> if none. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Memory"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.MemoryIndex">
            <summary>
            Gets the memory operand's index register or <see cref="F:Iced.Intel.Register.None"/> if none. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Memory"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Op0Register">
            <summary>
            Gets operand #0's register value. Use this property if operand #0 (<see cref="P:Iced.Intel.Instruction.Op0Kind"/>) has kind <see cref="F:Iced.Intel.OpKind.Register"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Op1Register">
            <summary>
            Gets operand #1's register value. Use this property if operand #1 (<see cref="P:Iced.Intel.Instruction.Op1Kind"/>) has kind <see cref="F:Iced.Intel.OpKind.Register"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Op2Register">
            <summary>
            Gets operand #2's register value. Use this property if operand #2 (<see cref="P:Iced.Intel.Instruction.Op2Kind"/>) has kind <see cref="F:Iced.Intel.OpKind.Register"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Op3Register">
            <summary>
            Gets operand #3's register value. Use this property if operand #3 (<see cref="P:Iced.Intel.Instruction.Op3Kind"/>) has kind <see cref="F:Iced.Intel.OpKind.Register"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Op4Register">
            <summary>
            Gets operand #4's register value. Use this property if operand #4 (<see cref="P:Iced.Intel.Instruction.Op4Kind"/>) has kind <see cref="F:Iced.Intel.OpKind.Register"/>
            </summary>
        </member>
        <member name="M:Iced.Intel.Instruction.GetOpRegister(System.Int32)">
            <summary>
            Gets the operand's register value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Register"/>
            </summary>
            <param name="operand">Operand number, 0-4</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.SetOpRegister(System.Int32,Iced.Intel.Register)">
            <summary>
            Sets the operand's register value. Use this property if the operand has kind <see cref="F:Iced.Intel.OpKind.Register"/>
            </summary>
            <param name="operand">Operand number, 0-4</param>
            <param name="register">Register</param>
        </member>
        <member name="P:Iced.Intel.Instruction.OpMask">
            <summary>
            Gets the opmask register (<see cref="F:Iced.Intel.Register.K1"/> - <see cref="F:Iced.Intel.Register.K7"/>) or <see cref="F:Iced.Intel.Register.None"/> if none
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.HasOpMask">
            <summary>
            true if there's an opmask register (<see cref="P:Iced.Intel.Instruction.OpMask"/>)
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.ZeroingMasking">
            <summary>
            true if zeroing-masking, false if merging-masking.
            Only used by most EVEX encoded instructions that use opmask registers.
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.MergingMasking">
            <summary>
            true if merging-masking, false if zeroing-masking.
            Only used by most EVEX encoded instructions that use opmask registers.
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.RoundingControl">
            <summary>
            Rounding control (<see cref="P:Iced.Intel.Instruction.SuppressAllExceptions"/> is implied but still returns false)
            or <see cref="F:Iced.Intel.RoundingControl.None"/> if the instruction doesn't use it.
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.DeclareDataCount">
            <summary>
            Number of elements in a db/dw/dd/dq directive.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareByte"/>, <see cref="F:Iced.Intel.Code.DeclareWord"/>, <see cref="F:Iced.Intel.Code.DeclareDword"/>, <see cref="F:Iced.Intel.Code.DeclareQword"/>
            </summary>
        </member>
        <member name="M:Iced.Intel.Instruction.SetDeclareByteValue(System.Int32,System.SByte)">
            <summary>
            Sets a new 'db' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareByte"/>
            </summary>
            <param name="index">Index</param>
            <param name="value">New value</param>
        </member>
        <member name="M:Iced.Intel.Instruction.SetDeclareByteValue(System.Int32,System.Byte)">
            <summary>
            Sets a new 'db' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareByte"/>
            </summary>
            <param name="index">Index</param>
            <param name="value">New value</param>
        </member>
        <member name="M:Iced.Intel.Instruction.GetDeclareByteValue(System.Int32)">
            <summary>
            Gets a 'db' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareByte"/>
            </summary>
            <param name="index">Index</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.SetDeclareWordValue(System.Int32,System.Int16)">
            <summary>
            Sets a new 'dw' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareWord"/>
            </summary>
            <param name="index">Index</param>
            <param name="value">New value</param>
        </member>
        <member name="M:Iced.Intel.Instruction.SetDeclareWordValue(System.Int32,System.UInt16)">
            <summary>
            Sets a new 'dw' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareWord"/>
            </summary>
            <param name="index">Index</param>
            <param name="value">New value</param>
        </member>
        <member name="M:Iced.Intel.Instruction.GetDeclareWordValue(System.Int32)">
            <summary>
            Gets a 'dw' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareWord"/>
            </summary>
            <param name="index">Index</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.SetDeclareDwordValue(System.Int32,System.Int32)">
            <summary>
            Sets a new 'dd' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareDword"/>
            </summary>
            <param name="index">Index</param>
            <param name="value">New value</param>
        </member>
        <member name="M:Iced.Intel.Instruction.SetDeclareDwordValue(System.Int32,System.UInt32)">
            <summary>
            Sets a new 'dd' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareDword"/>
            </summary>
            <param name="index">Index</param>
            <param name="value">New value</param>
        </member>
        <member name="M:Iced.Intel.Instruction.GetDeclareDwordValue(System.Int32)">
            <summary>
            Gets a 'dd' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareDword"/>
            </summary>
            <param name="index">Index</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.SetDeclareQwordValue(System.Int32,System.Int64)">
            <summary>
            Sets a new 'dq' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareQword"/>
            </summary>
            <param name="index">Index</param>
            <param name="value">New value</param>
        </member>
        <member name="M:Iced.Intel.Instruction.SetDeclareQwordValue(System.Int32,System.UInt64)">
            <summary>
            Sets a new 'dq' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareQword"/>
            </summary>
            <param name="index">Index</param>
            <param name="value">New value</param>
        </member>
        <member name="M:Iced.Intel.Instruction.GetDeclareQwordValue(System.Int32)">
            <summary>
            Gets a 'dq' value, see also <see cref="P:Iced.Intel.Instruction.DeclareDataCount"/>.
            Can only be called if <see cref="P:Iced.Intel.Instruction.Code"/> is <see cref="F:Iced.Intel.Code.DeclareQword"/>
            </summary>
            <param name="index">Index</param>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsVsib">
            <summary>
            Checks if this is a VSIB instruction, see also <see cref="P:Iced.Intel.Instruction.IsVsib32"/>, <see cref="P:Iced.Intel.Instruction.IsVsib64"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IsVsib32">
            <summary>
            VSIB instructions only (<see cref="P:Iced.Intel.Instruction.IsVsib"/>): true if it's using 32-bit indexes, false if it's using 64-bit indexes
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IsVsib64">
            <summary>
            VSIB instructions only (<see cref="P:Iced.Intel.Instruction.IsVsib"/>): true if it's using 64-bit indexes, false if it's using 32-bit indexes
            </summary>
        </member>
        <member name="M:Iced.Intel.Instruction.TryGetVsib64(System.Boolean@)">
            <summary>
            Checks if it's a VSIB instruction. If it's a VSIB instruction, it sets <paramref name="vsib64"/> to true if it's
            a VSIB instruction with 64-bit indexes, and clears it if it's using 32-bit indexes.
            </summary>
            <param name="vsib64">If it's a VSIB instruction, set to true if it's using 64-bit indexes, set to false if it's using 32-bit indexes</param>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.SuppressAllExceptions">
            <summary>
            Suppress all exceptions (EVEX encoded instructions). Note that if <see cref="P:Iced.Intel.Instruction.RoundingControl"/> is
            not <see cref="F:Iced.Intel.RoundingControl.None"/>, SAE is implied but this property will still return false.
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IsIPRelativeMemoryOp">
            <summary>
            Checks if the memory operand is RIP/EIP relative
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IsIPRelativeMemoryOperand">
            <summary>
            Checks if the memory operand is RIP/EIP relative
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IPRelativeMemoryAddress">
            <summary>
            Gets the RIP/EIP releative address ((<see cref="P:Iced.Intel.Instruction.NextIP"/> or <see cref="P:Iced.Intel.Instruction.NextIP32"/>) + <see cref="P:Iced.Intel.Instruction.MemoryDisplacement"/>). This property is only valid if there's a memory operand with RIP/EIP relative addressing.
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.OpCode">
            <summary>
            Gets the <see cref="T:Iced.Intel.OpCodeInfo"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.ToString">
            <summary>
            Formats the instruction using the default formatter with default formatter options
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.StackPointerIncrement">
            <summary>
            Gets the number of bytes added to SP/ESP/RSP or 0 if it's not an instruction that pushes or pops data. This method
            assumes the instruction doesn't change privilege (eg. iret/d/q). If it's the leave instruction, this method returns 0.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.GetInfo">
            <summary>
            (This method allocates and is slower than using an <see cref="T:Iced.Intel.InstructionInfoFactory"/>.)
            
            Gets instruction info such as which register is read and written etc.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.GetInfo(Iced.Intel.InstructionInfoOptions)">
            <summary>
            (This method allocates and is slower than using an <see cref="T:Iced.Intel.InstructionInfoFactory"/>.)
            
            Gets instruction info such as which register is read and written etc.
            </summary>
            <param name="options">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.GetUsedRegisters">
            <summary>
            (This method allocates and is slower than using an <see cref="T:Iced.Intel.InstructionInfoFactory"/>.)
            
            Gets a struct iterator that returns all read and written registers. There are some exceptions, this method doesn't return all used registers:
            
            1) If <see cref="P:Iced.Intel.Instruction.SaveRestoreInstruction"/> is true, or
            
            2) If it's a <see cref="F:Iced.Intel.FlowControl.Call"/> or <see cref="F:Iced.Intel.FlowControl.Interrupt"/> instruction (call, sysenter, int n etc), it can read and write any register (including RFLAGS).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.GetUsedMemory">
            <summary>
            (This method allocates and is slower than using an <see cref="T:Iced.Intel.InstructionInfoFactory"/>.)
            
            Gets a struct iterator that returns all read and written memory locations
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.Encoding">
            <summary>
            Instruction encoding, eg. legacy, VEX, EVEX, ...
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.CpuidFeature">
            <summary>
            CPU or CPUID feature flag
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.CpuidFeatures">
            <summary>
            Gets the CPU or CPUID feature flags
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.FlowControl">
            <summary>
            Flow control info
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.ProtectedMode">
            <summary>
            true if the instruction isn't available in real mode or virtual 8086 mode
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IsProtectedMode">
            <summary>
            true if the instruction isn't available in real mode or virtual 8086 mode
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.Privileged">
            <summary>
            true if this is a privileged instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IsPrivileged">
            <summary>
            true if this is a privileged instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.StackInstruction">
            <summary>
            true if this is an instruction that implicitly uses the stack pointer (SP/ESP/RSP), eg. call, push, pop, ret, etc.
            See also <see cref="P:Iced.Intel.Instruction.StackPointerIncrement"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IsStackInstruction">
            <summary>
            true if this is an instruction that implicitly uses the stack pointer (SP/ESP/RSP), eg. call, push, pop, ret, etc.
            See also <see cref="P:Iced.Intel.Instruction.StackPointerIncrement"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.SaveRestoreInstruction">
            <summary>
            true if it's an instruction that saves or restores too many registers (eg. fxrstor, xsave, etc).
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IsSaveRestoreInstruction">
            <summary>
            true if it's an instruction that saves or restores too many registers (eg. fxrstor, xsave, etc).
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.RflagsRead">
            <summary>
            All flags that are read by the CPU when executing the instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.RflagsWritten">
            <summary>
            All flags that are written by the CPU, except those flags that are known to be undefined, always set or always cleared. See also <see cref="P:Iced.Intel.Instruction.RflagsModified"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.RflagsCleared">
            <summary>
            All flags that are always cleared by the CPU
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.RflagsSet">
            <summary>
            All flags that are always set by the CPU
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.RflagsUndefined">
            <summary>
            All flags that are undefined after executing the instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.RflagsModified">
            <summary>
            All flags that are modified by the CPU. This is <see cref="P:Iced.Intel.Instruction.RflagsWritten"/> + <see cref="P:Iced.Intel.Instruction.RflagsCleared"/> + <see cref="P:Iced.Intel.Instruction.RflagsSet"/> + <see cref="P:Iced.Intel.Instruction.RflagsUndefined"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.IsJccShortOrNear">
            <summary>
            Checks if it's a jcc short or jcc near instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsJccNear">
            <summary>
            Checks if it's a jcc near instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsJccShort">
            <summary>
            Checks if it's a jcc short instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsJmpShort">
            <summary>
            Checks if it's a jmp short instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsJmpNear">
            <summary>
            Checks if it's a jmp near instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsJmpShortOrNear">
            <summary>
            Checks if it's a jmp short or a jmp near instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsJmpFar">
            <summary>
            Checks if it's a jmp far instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsCallNear">
            <summary>
            Checks if it's a call near instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsCallFar">
            <summary>
            Checks if it's a call far instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsJmpNearIndirect">
            <summary>
            Checks if it's a jmp near reg/[mem] instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsJmpFarIndirect">
            <summary>
            Checks if it's a jmp far [mem] instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsCallNearIndirect">
            <summary>
            Checks if it's a call near reg/[mem] instruction
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.Instruction.IsCallFarIndirect">
            <summary>
            Checks if it's a call far [mem] instruction
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.NegateConditionCode">
            <summary>
            Negates the condition code, eg. je -> jne. Can be used if it's jcc, setcc, cmovcc and does
            nothing if the instruction doesn't have a condition code.
            </summary>
        </member>
        <member name="M:Iced.Intel.Instruction.ToShortBranch">
            <summary>
            Converts jcc near to jcc short and does nothing if it's not a jcc near instruction
            </summary>
        </member>
        <member name="M:Iced.Intel.Instruction.ToNearBranch">
            <summary>
            Converts jcc short to jcc near and does nothing if it's not a jcc short instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.Instruction.ConditionCode">
            <summary>
            Gets the condition code if it's jcc, setcc, cmovcc else <see cref="F:Iced.Intel.ConditionCode.None"/> is returned
            </summary>
        </member>
        <member name="M:Iced.Intel.Instruction.GetVirtualAddress(System.Int32,System.Int32,Iced.Intel.VAGetRegisterValue)">
            <summary>
            Gets the virtual address of a memory operand
            </summary>
            <param name="operand">Operand number, must be a memory operand</param>
            <param name="elementIndex">Only used if it's a vsib memory operand. This is the element index of the vector index register.</param>
            <param name="getRegisterValue">Delegate that returns the value of a register or the base address of a segment register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.Instruction.GetVirtualAddress(System.Int32,System.Int32,Iced.Intel.IVARegisterValueProvider)">
            <summary>
            Gets the virtual address of a memory operand
            </summary>
            <param name="operand">Operand number, must be a memory operand</param>
            <param name="elementIndex">Only used if it's a vsib memory operand. This is the element index of the vector index register.</param>
            <param name="registerValueProvider">Returns values of registers and segment base addresses</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.RepPrefixKind">
            <summary>
            rep/repe/repne prefix
            </summary>
        </member>
        <member name="F:Iced.Intel.RepPrefixKind.None">
            <summary>
            No rep/repe/repne prefix
            </summary>
        </member>
        <member name="F:Iced.Intel.RepPrefixKind.Repe">
            <summary>
            repe prefix
            </summary>
        </member>
        <member name="F:Iced.Intel.RepPrefixKind.Repne">
            <summary>
            repne prefix
            </summary>
        </member>
        <member name="F:Iced.Intel.RepPrefixKind.Rep">
            <summary>
            rep prefix
            </summary>
        </member>
        <member name="T:Iced.Intel.VAGetRegisterValue">
            <summary>
            Gets a register value. If <paramref name="register"/> is a segment register, this method should return the segment's base value,
            not the segment register value.
            </summary>
            <param name="register">Register (GPR8, GPR16, GPR32, GPR64, XMM, YMM, ZMM, seg)</param>
            <param name="elementIndex">Only used if it's a vsib memory operand. This is the element index in the vector register.</param>
            <param name="elementSize">Only used if it's a vsib memory operand. Size in bytes of elements in vector index register (4 or 8).</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.IVARegisterValueProvider">
            <summary>
            Called when calculating the virtual address of a memory operand
            </summary>
        </member>
        <member name="M:Iced.Intel.IVARegisterValueProvider.GetRegisterValue(Iced.Intel.Register,System.Int32,System.Int32)">
            <summary>
            Gets a register value. If <paramref name="register"/> is a segment register, this method should return the segment's base value,
            not the segment register value.
            </summary>
            <param name="register">Register (GPR8, GPR16, GPR32, GPR64, XMM, YMM, ZMM, seg)</param>
            <param name="elementIndex">Only used if it's a vsib memory operand. This is the element index in the vector register.</param>
            <param name="elementSize">Only used if it's a vsib memory operand. Size in bytes of elements in vector index register (4 or 8).</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.InstructionInfo">
            <summary>
            Contains information about an instruction, eg. read/written registers, read/written RFLAGS bits, CPUID feature bit, etc
            </summary>
        </member>
        <member name="M:Iced.Intel.InstructionInfo.GetUsedRegisters">
            <summary>
            Gets a struct iterator that returns all read and written registers. There are some exceptions, this method doesn't return all used registers:
            
            1) If <see cref="P:Iced.Intel.InstructionInfo.SaveRestoreInstruction"/> is true, or
            
            2) If it's a <see cref="F:Iced.Intel.FlowControl.Call"/> or <see cref="F:Iced.Intel.FlowControl.Interrupt"/> instruction (call, sysenter, int n etc), it can read and write any register (including RFLAGS).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfo.GetUsedMemory">
            <summary>
            Gets a struct iterator that returns all read and written memory locations
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.ProtectedMode">
            <summary>
            true if the instruction isn't available in real mode or virtual 8086 mode
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.IsProtectedMode">
            <summary>
            true if the instruction isn't available in real mode or virtual 8086 mode
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.Privileged">
            <summary>
            true if this is a privileged instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.IsPrivileged">
            <summary>
            true if this is a privileged instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.StackInstruction">
            <summary>
            true if this is an instruction that implicitly uses the stack pointer (SP/ESP/RSP), eg. call, push, pop, ret, etc.
            See also <see cref="P:Iced.Intel.Instruction.StackPointerIncrement"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.IsStackInstruction">
            <summary>
            true if this is an instruction that implicitly uses the stack pointer (SP/ESP/RSP), eg. call, push, pop, ret, etc.
            See also <see cref="P:Iced.Intel.Instruction.StackPointerIncrement"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.SaveRestoreInstruction">
            <summary>
            true if it's an instruction that saves or restores too many registers (eg. fxrstor, xsave, etc).
            <see cref="M:Iced.Intel.InstructionInfo.GetUsedRegisters"/> won't return all read/written registers.
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.IsSaveRestoreInstruction">
            <summary>
            true if it's an instruction that saves or restores too many registers (eg. fxrstor, xsave, etc).
            <see cref="M:Iced.Intel.InstructionInfo.GetUsedRegisters"/> won't return all read/written registers.
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.Encoding">
            <summary>
            Instruction encoding, eg. legacy, VEX, EVEX, ...
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.CpuidFeature">
            <summary>
            CPU or CPUID feature flag
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.CpuidFeatures">
            <summary>
            Gets the CPU or CPUID feature flags
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.FlowControl">
            <summary>
            Flow control info
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.Op0Access">
            <summary>
            Operand #0 access
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.Op1Access">
            <summary>
            Operand #1 access
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.Op2Access">
            <summary>
            Operand #2 access
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.Op3Access">
            <summary>
            Operand #3 access
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.Op4Access">
            <summary>
            Operand #4 access
            </summary>
        </member>
        <member name="M:Iced.Intel.InstructionInfo.GetOpAccess(System.Int32)">
            <summary>
            Gets operand access
            </summary>
            <param name="operand">Operand number, 0-4</param>
            <returns></returns>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.RflagsRead">
            <summary>
            All flags that are read by the CPU when executing the instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.RflagsWritten">
            <summary>
            All flags that are written by the CPU, except those flags that are known to be undefined, always set or always cleared. See also <see cref="P:Iced.Intel.InstructionInfo.RflagsModified"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.RflagsCleared">
            <summary>
            All flags that are always cleared by the CPU
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.RflagsSet">
            <summary>
            All flags that are always set by the CPU
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.RflagsUndefined">
            <summary>
            All flags that are undefined after executing the instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionInfo.RflagsModified">
            <summary>
            All flags that are modified by the CPU. This is <see cref="P:Iced.Intel.InstructionInfo.RflagsWritten"/> + <see cref="P:Iced.Intel.InstructionInfo.RflagsCleared"/> + <see cref="P:Iced.Intel.InstructionInfo.RflagsSet"/> + <see cref="P:Iced.Intel.InstructionInfo.RflagsUndefined"/>
            </summary>
        </member>
        <member name="T:Iced.Intel.InstructionInfoExtensions">
            <summary>
            Extension methods
            </summary>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.Encoding(Iced.Intel.Code)">
            <summary>
            Gets the encoding, eg. legacy, VEX, EVEX, ...
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.CpuidFeature(Iced.Intel.Code)">
            <summary>
            Gets the CPU or CPUID feature flag
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.CpuidFeatures(Iced.Intel.Code)">
            <summary>
            Gets the CPU or CPUID feature flags
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.FlowControl(Iced.Intel.Code)">
            <summary>
            Gets flow control info
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.ProtectedMode(Iced.Intel.Code)">
            <summary>
            Checks if the instruction isn't available in real mode or virtual 8086 mode
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsProtectedMode(Iced.Intel.Code)">
            <summary>
            Checks if the instruction isn't available in real mode or virtual 8086 mode
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.Privileged(Iced.Intel.Code)">
            <summary>
            Checks if this is a privileged instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsPrivileged(Iced.Intel.Code)">
            <summary>
            Checks if this is a privileged instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.StackInstruction(Iced.Intel.Code)">
            <summary>
            Checks if this is an instruction that implicitly uses the stack pointer (SP/ESP/RSP), eg. call, push, pop, ret, etc.
            See also <see cref="P:Iced.Intel.Instruction.StackPointerIncrement"/>
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsStackInstruction(Iced.Intel.Code)">
            <summary>
            Checks if this is an instruction that implicitly uses the stack pointer (SP/ESP/RSP), eg. call, push, pop, ret, etc.
            See also <see cref="P:Iced.Intel.Instruction.StackPointerIncrement"/>
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.SaveRestoreInstruction(Iced.Intel.Code)">
            <summary>
            Checks if it's an instruction that saves or restores too many registers (eg. fxrstor, xsave, etc).
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsSaveRestoreInstruction(Iced.Intel.Code)">
            <summary>
            Checks if it's an instruction that saves or restores too many registers (eg. fxrstor, xsave, etc).
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsJccShortOrNear(Iced.Intel.Code)">
            <summary>
            Checks if it's a jcc short or jcc near instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsJccNear(Iced.Intel.Code)">
            <summary>
            Checks if it's a jcc near instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsJccShort(Iced.Intel.Code)">
            <summary>
            Checks if it's a jcc short instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsJmpShort(Iced.Intel.Code)">
            <summary>
            Checks if it's a jmp short instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsJmpNear(Iced.Intel.Code)">
            <summary>
            Checks if it's a jmp near instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsJmpShortOrNear(Iced.Intel.Code)">
            <summary>
            Checks if it's a jmp short or a jmp near instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsJmpFar(Iced.Intel.Code)">
            <summary>
            Checks if it's a jmp far instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsCallNear(Iced.Intel.Code)">
            <summary>
            Checks if it's a call near instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsCallFar(Iced.Intel.Code)">
            <summary>
            Checks if it's a call far instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsJmpNearIndirect(Iced.Intel.Code)">
            <summary>
            Checks if it's a jmp near reg/[mem] instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsJmpFarIndirect(Iced.Intel.Code)">
            <summary>
            Checks if it's a jmp far [mem] instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsCallNearIndirect(Iced.Intel.Code)">
            <summary>
            Checks if it's a call near reg/[mem] instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.IsCallFarIndirect(Iced.Intel.Code)">
            <summary>
            Checks if it's a call far [mem] instruction
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.NegateConditionCode(Iced.Intel.Code)">
            <summary>
            Negates the condition code, eg. je -> jne. Can be used if it's jcc, setcc, cmovcc and returns
            the original value if it's none of those instructions.
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.ToShortBranch(Iced.Intel.Code)">
            <summary>
            Converts jcc/jmp near to jcc/jmp short. Returns the input if it's not a jcc/jmp near instruction.
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.ToNearBranch(Iced.Intel.Code)">
            <summary>
            Converts jcc/jmp short to jcc/jmp near. Returns the input if it's not a jcc/jmp short instruction.
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoExtensions.GetConditionCode(Iced.Intel.Code)">
            <summary>
            Gets the condition code if it's jcc, setcc, cmovcc else <see cref="F:Iced.Intel.ConditionCode.None"/> is returned
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.InstructionInfoOptions">
            <summary>
            Instruction info options
            </summary>
        </member>
        <member name="F:Iced.Intel.InstructionInfoOptions.None">
            <summary>
            No option is enabled
            </summary>
        </member>
        <member name="F:Iced.Intel.InstructionInfoOptions.NoMemoryUsage">
            <summary>
            Don't include memory usage, eg. <see cref="M:Iced.Intel.InstructionInfo.GetUsedMemory"/> will return an empty iterator. All
            registers that are used by memory operands are still returned by <see cref="M:Iced.Intel.InstructionInfo.GetUsedRegisters"/>.
            </summary>
        </member>
        <member name="F:Iced.Intel.InstructionInfoOptions.NoRegisterUsage">
            <summary>
            Don't include register usage, eg. <see cref="M:Iced.Intel.InstructionInfo.GetUsedRegisters"/> will return an empty iterator
            </summary>
        </member>
        <member name="T:Iced.Intel.InstructionInfoFactory">
            <summary>
            Creates <see cref="T:Iced.Intel.InstructionInfo"/>s but minimizes allocations
            </summary>
        </member>
        <member name="M:Iced.Intel.InstructionInfoFactory.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Iced.Intel.InstructionInfoFactory.GetInfo(Iced.Intel.Instruction@)">
            <summary>
            Creates an <see cref="T:Iced.Intel.InstructionInfo"/>. The return value is only valid until this instance creates a new <see cref="T:Iced.Intel.InstructionInfo"/> value.
            </summary>
            <param name="instruction">Instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionInfoFactory.GetInfo(Iced.Intel.Instruction@,Iced.Intel.InstructionInfoOptions)">
            <summary>
            Creates an <see cref="T:Iced.Intel.InstructionInfo"/>. The return value is only valid until this instance creates a new <see cref="T:Iced.Intel.InstructionInfo"/> value.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="options">Options</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.InstructionList">
            <summary>
            A list of <see cref="T:Iced.Intel.Instruction"/>s. It's faster than <see cref="T:System.Collections.Generic.List`1"/> and has
            methods to get references to the elements so no <see cref="T:Iced.Intel.Instruction"/> gets copied.
            Use 'foreach (ref var instr in list)' to use the foreach ref iterator.
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionList.Count">
            <summary>
            Gets the number of valid elements
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionList.Capacity">
            <summary>
            Gets the size of the internal array
            </summary>
        </member>
        <member name="P:Iced.Intel.InstructionList.Item(System.Int32)">
            <summary>
            Gets a reference to an element. The returned reference is valid until the internal array is resized.
            </summary>
            <param name="index">Index of element</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Iced.Intel.InstructionList.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="capacity">Initial size of the internal array</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.#ctor(Iced.Intel.InstructionList)">
            <summary>
            Constructor
            </summary>
            <param name="list">List that will be copied to this instance</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.#ctor(System.Collections.Generic.IEnumerable{Iced.Intel.Instruction})">
            <summary>
            Constructor
            </summary>
            <param name="collection">Collection that will be copied to this instance</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.AllocUninitializedElement">
            <summary>
            Allocates an uninitialized element at the end of the list and returns a reference to it.
            The return value can be passed to eg. Decoder.Decode(out Instruction).
            The returned reference is valid until the internal array is resized.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.Insert(System.Int32,Iced.Intel.Instruction@)">
            <summary>
            Inserts an element
            </summary>
            <param name="index">Index of element</param>
            <param name="instruction">Instruction to add</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.RemoveAt(System.Int32)">
            <summary>
            Removes an element from the list
            </summary>
            <param name="index">Index of element to remove</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.AddRange(System.Collections.Generic.IEnumerable{Iced.Intel.Instruction})">
            <summary>
            Adds a collection to the end of this list
            </summary>
            <param name="collection">Collection to add</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{Iced.Intel.Instruction})">
            <summary>
            Inserts elements
            </summary>
            <param name="index">Index of element</param>
            <param name="collection">Items to insert</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes elements
            </summary>
            <param name="index">Index of element</param>
            <param name="count">Number of elements to remove</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.Add(Iced.Intel.Instruction@)">
            <summary>
            Adds a new instruction to the end of the list
            </summary>
            <param name="instruction">Instruction to add</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.Clear">
            <summary>
            Clears the list
            </summary>
        </member>
        <member name="M:Iced.Intel.InstructionList.Contains(Iced.Intel.Instruction@)">
            <summary>
            Checks if <paramref name="instruction"/> exists in the list
            </summary>
            <param name="instruction">Instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.IndexOf(Iced.Intel.Instruction@)">
            <summary>
            Gets the index of <paramref name="instruction"/> or -1 if it doesn't exist in the list
            </summary>
            <param name="instruction">Instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.IndexOf(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Gets the index of <paramref name="instruction"/> or -1 if it doesn't exist in the list
            </summary>
            <param name="instruction">Instruction</param>
            <param name="index">Start index</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.IndexOf(Iced.Intel.Instruction@,System.Int32,System.Int32)">
            <summary>
            Gets the index of <paramref name="instruction"/> or -1 if it doesn't exist in the list
            </summary>
            <param name="instruction">Instruction</param>
            <param name="index">Start index</param>
            <param name="count">Number of instructions to check</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.LastIndexOf(Iced.Intel.Instruction@)">
            <summary>
            Gets the last index of <paramref name="instruction"/> or -1 if it doesn't exist in the list
            </summary>
            <param name="instruction">Instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.LastIndexOf(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Gets the last index of <paramref name="instruction"/> or -1 if it doesn't exist in the list
            </summary>
            <param name="instruction">Instruction</param>
            <param name="index">Start index</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.LastIndexOf(Iced.Intel.Instruction@,System.Int32,System.Int32)">
            <summary>
            Gets the last index of <paramref name="instruction"/> or -1 if it doesn't exist in the list
            </summary>
            <param name="instruction">Instruction</param>
            <param name="index">Start index</param>
            <param name="count">Number of instructions to check</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.Remove(Iced.Intel.Instruction@)">
            <summary>
            Removes the first copy of <paramref name="instruction"/> and returns true if it was removed
            </summary>
            <param name="instruction">Instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.CopyTo(Iced.Intel.Instruction[])">
            <summary>
            Copies this collection to <paramref name="array"/>
            </summary>
            <param name="array">Destination array</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.CopyTo(Iced.Intel.Instruction[],System.Int32)">
            <summary>
            Copies this collection to <paramref name="array"/>
            </summary>
            <param name="array">Destination array</param>
            <param name="arrayIndex">Start index in <paramref name="array"/></param>
        </member>
        <member name="M:Iced.Intel.InstructionList.CopyTo(System.Int32,Iced.Intel.Instruction[],System.Int32,System.Int32)">
            <summary>
            Copies this collection to <paramref name="array"/>
            </summary>
            <param name="index">Index in this collection</param>
            <param name="array">Destination array</param>
            <param name="arrayIndex">Destination index</param>
            <param name="count">Number of elements to copy</param>
        </member>
        <member name="M:Iced.Intel.InstructionList.GetRange(System.Int32,System.Int32)">
            <summary>
            Creates a new list that contains some of the instructions in this list
            </summary>
            <param name="index">Index of first instruction</param>
            <param name="count">Number of instructions</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.GetEnumerator">
            <summary>
            Gets a ref iterator (use 'foreach ref')
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.AsReadOnly">
            <summary>
            Returns a read-only wrapper for this list
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.InstructionList.ToArray">
            <summary>
            Creates a new array with all instructions and returns it
            </summary>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.IntelFormatterOptions">
            <summary>
            Intel formatter options
            </summary>
        </member>
        <member name="M:Iced.Intel.IntelFormatterOptions.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Iced.Intel.IntelFormatter">
            <summary>
            Intel formatter (same as Intel XED)
            </summary>
        </member>
        <member name="P:Iced.Intel.IntelFormatter.Options">
            <summary>
            Gets the formatter options, see also <see cref="P:Iced.Intel.IntelFormatter.IntelOptions"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.IntelFormatter.IntelOptions">
            <summary>
            Gets the Intel formatter options
            </summary>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.#ctor(Iced.Intel.IntelFormatterOptions,Iced.Intel.ISymbolResolver,Iced.Intel.IFormatterOptionsProvider)">
            <summary>
            Constructor
            </summary>
            <param name="options">Formatter options or null</param>
            <param name="symbolResolver">Symbol resolver or null</param>
            <param name="optionsProvider">Operand options provider or null</param>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatMnemonic(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput,Iced.Intel.FormatMnemonicOptions)">
            <summary>
            Formats the mnemonic and any prefixes
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
            <param name="options">Options</param>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.GetOperandCount(Iced.Intel.Instruction@)">
            <summary>
            Gets the number of operands that will be formatted. A formatter can add and remove operands
            </summary>
            <param name="instruction">Instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.TryGetOpAccess(Iced.Intel.Instruction@,System.Int32,Iced.Intel.OpAccess@)">
            <summary>
            Returns the operand access but only if it's an operand added by the formatter. If it's an
            operand that is part of <see cref="T:Iced.Intel.Instruction"/>, you should call eg.
            <see cref="M:Iced.Intel.Instruction.GetInfo"/> or <see cref="M:Iced.Intel.InstructionInfoFactory.GetInfo(Iced.Intel.Instruction@)"/>.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.IntelFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
            <param name="access">Updated with operand access if successful</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.GetInstructionOperand(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Converts a formatter operand index to an instruction operand index. Returns -1 if it's an operand added by the formatter
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.IntelFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.GetFormatterOperand(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Converts an instruction operand index to a formatter operand index. Returns -1 if the instruction operand isn't used by the formatter
            </summary>
            <param name="instruction">Instruction</param>
            <param name="instructionOperand">Instruction operand</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatOperand(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput,System.Int32)">
            <summary>
            Formats an operand. This is a formatter operand and not necessarily a real instruction operand.
            A formatter can add and remove operands.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.IntelFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatOperandSeparator(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats an operand separator
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatAllOperands(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats all operands
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.Format(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats the whole instruction: prefixes, mnemonic, operands
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.Format(Iced.Intel.Register)">
            <summary>
            Formats a register
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatInt8(System.SByte,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.SByte"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatInt16(System.Int16,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int16"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatInt32(System.Int32,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int32"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatInt64(System.Int64,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int64"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatUInt8(System.Byte,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Byte"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatUInt16(System.UInt16,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt16"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatUInt32(System.UInt32,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.IntelFormatter.FormatUInt64(System.UInt64,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt64"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.ISymbolResolver">
            <summary>
            Used by a <see cref="T:Iced.Intel.Formatter"/> to resolve symbols
            </summary>
        </member>
        <member name="M:Iced.Intel.ISymbolResolver.TryGetSymbol(Iced.Intel.Instruction@,System.Int32,System.Int32,System.UInt64,System.Int32,Iced.Intel.SymbolResult@)">
            <summary>
            Tries to resolve a symbol. It returns true if <paramref name="symbol"/> was updated.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.</param>
            <param name="instructionOperand">Instruction operand number, 0-based, or -1 if it's an operand created by the formatter.</param>
            <param name="address">Address</param>
            <param name="addressSize">Size of <paramref name="address"/> in bytes</param>
            <param name="symbol">Updated with symbol information if this method returns true</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.SymbolFlags">
            <summary>
            Symbol flags
            </summary>
        </member>
        <member name="F:Iced.Intel.SymbolFlags.None">
            <summary>
            No bit is set
            </summary>
        </member>
        <member name="F:Iced.Intel.SymbolFlags.Relative">
            <summary>
            It's a symbol relative to a register, eg. a struct offset `[ebx+some_struct.field1]`. If this is
            cleared, it's the address of a symbol.
            </summary>
        </member>
        <member name="F:Iced.Intel.SymbolFlags.Signed">
            <summary>
            It's a signed symbol and it should be displayed as '-symbol' or 'reg-symbol' instead of 'symbol' or 'reg+symbol'
            </summary>
        </member>
        <member name="F:Iced.Intel.SymbolFlags.HasSymbolSize">
            <summary>
            Set if <see cref="F:Iced.Intel.SymbolResult.SymbolSize"/> is valid
            </summary>
        </member>
        <member name="T:Iced.Intel.SymbolResult">
            <summary>
            The result of resolving a symbol
            </summary>
        </member>
        <member name="F:Iced.Intel.SymbolResult.Address">
            <summary>
            The address of the symbol
            </summary>
        </member>
        <member name="F:Iced.Intel.SymbolResult.Text">
            <summary>
            Contains the symbol
            </summary>
        </member>
        <member name="F:Iced.Intel.SymbolResult.Flags">
            <summary>
            Symbol flags
            </summary>
        </member>
        <member name="P:Iced.Intel.SymbolResult.HasSymbolSize">
            <summary>
            Checks whether <see cref="F:Iced.Intel.SymbolResult.SymbolSize"/> is valid
            </summary>
        </member>
        <member name="F:Iced.Intel.SymbolResult.SymbolSize">
            <summary>
            Symbol size if <see cref="P:Iced.Intel.SymbolResult.HasSymbolSize"/> is true
            </summary>
        </member>
        <member name="M:Iced.Intel.SymbolResult.#ctor(System.UInt64,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="address">The address of the symbol</param>
            <param name="text">Symbol</param>
        </member>
        <member name="M:Iced.Intel.SymbolResult.#ctor(System.UInt64,System.String,Iced.Intel.MemorySize)">
            <summary>
            Constructor
            </summary>
            <param name="address">The address of the symbol</param>
            <param name="text">Symbol</param>
            <param name="size">Symbol size</param>
        </member>
        <member name="M:Iced.Intel.SymbolResult.#ctor(System.UInt64,System.String,Iced.Intel.FormatterOutputTextKind)">
            <summary>
            Constructor
            </summary>
            <param name="address">The address of the symbol</param>
            <param name="text">Symbol</param>
            <param name="color">Color</param>
        </member>
        <member name="M:Iced.Intel.SymbolResult.#ctor(System.UInt64,System.String,Iced.Intel.FormatterOutputTextKind,Iced.Intel.SymbolFlags)">
            <summary>
            Constructor
            </summary>
            <param name="address">The address of the symbol</param>
            <param name="text">Symbol</param>
            <param name="color">Color</param>
            <param name="flags">Symbol flags</param>
        </member>
        <member name="M:Iced.Intel.SymbolResult.#ctor(System.UInt64,Iced.Intel.TextInfo)">
            <summary>
            Constructor
            </summary>
            <param name="address">The address of the symbol</param>
            <param name="text">Symbol</param>
        </member>
        <member name="M:Iced.Intel.SymbolResult.#ctor(System.UInt64,Iced.Intel.TextInfo,Iced.Intel.MemorySize)">
            <summary>
            Constructor
            </summary>
            <param name="address">The address of the symbol</param>
            <param name="text">Symbol</param>
            <param name="size">Symbol size</param>
        </member>
        <member name="M:Iced.Intel.SymbolResult.#ctor(System.UInt64,Iced.Intel.TextInfo,Iced.Intel.SymbolFlags)">
            <summary>
            Constructor
            </summary>
            <param name="address">The address of the symbol</param>
            <param name="text">Symbol</param>
            <param name="flags">Symbol flags</param>
        </member>
        <member name="M:Iced.Intel.SymbolResult.#ctor(System.UInt64,Iced.Intel.TextInfo,Iced.Intel.SymbolFlags,Iced.Intel.MemorySize)">
            <summary>
            Constructor
            </summary>
            <param name="address">The address of the symbol</param>
            <param name="text">Symbol</param>
            <param name="flags">Symbol flags</param>
            <param name="size">Symbol size</param>
        </member>
        <member name="T:Iced.Intel.TextInfo">
            <summary>
            Contains one or more <see cref="T:Iced.Intel.TextPart"/>s (text and color)
            </summary>
        </member>
        <member name="P:Iced.Intel.TextInfo.IsDefault">
            <summary>
            true if this is the default instance
            </summary>
        </member>
        <member name="F:Iced.Intel.TextInfo.Text">
            <summary>
            The text and color unless <see cref="F:Iced.Intel.TextInfo.TextArray"/> is non-null
            </summary>
        </member>
        <member name="F:Iced.Intel.TextInfo.TextArray">
            <summary>
            Text and color or null if <see cref="F:Iced.Intel.TextInfo.Text"/> should be used
            </summary>
        </member>
        <member name="M:Iced.Intel.TextInfo.#ctor(System.String,Iced.Intel.FormatterOutputTextKind)">
            <summary>
            Constructor
            </summary>
            <param name="text">Text</param>
            <param name="color">Color</param>
        </member>
        <member name="M:Iced.Intel.TextInfo.#ctor(Iced.Intel.TextPart)">
            <summary>
            Constructor
            </summary>
            <param name="text">Text</param>
        </member>
        <member name="M:Iced.Intel.TextInfo.#ctor(Iced.Intel.TextPart[])">
            <summary>
            Constructor
            </summary>
            <param name="text">All text parts</param>
        </member>
        <member name="T:Iced.Intel.TextPart">
            <summary>
            Contains text and colors
            </summary>
        </member>
        <member name="F:Iced.Intel.TextPart.Text">
            <summary>
            Text
            </summary>
        </member>
        <member name="F:Iced.Intel.TextPart.Color">
            <summary>
            Color
            </summary>
        </member>
        <member name="M:Iced.Intel.TextPart.#ctor(System.String,Iced.Intel.FormatterOutputTextKind)">
            <summary>
            Constructor
            </summary>
            <param name="text">Text</param>
            <param name="color">Color</param>
        </member>
        <member name="T:Iced.Intel.MandatoryPrefix">
            <summary>
            Mandatory prefix
            </summary>
        </member>
        <member name="F:Iced.Intel.MandatoryPrefix.None">
            <summary>
            No mandatory prefix (legacy and 3DNow! tables only)
            </summary>
        </member>
        <member name="F:Iced.Intel.MandatoryPrefix.PNP">
            <summary>
            Empty mandatory prefix (no 66, F3 or F2 prefix)
            </summary>
        </member>
        <member name="F:Iced.Intel.MandatoryPrefix.P66">
            <summary>
            66 prefix
            </summary>
        </member>
        <member name="F:Iced.Intel.MandatoryPrefix.PF3">
            <summary>
            F3 prefix
            </summary>
        </member>
        <member name="F:Iced.Intel.MandatoryPrefix.PF2">
            <summary>
            F2 prefix
            </summary>
        </member>
        <member name="T:Iced.Intel.MasmFormatterOptions">
            <summary>
            Masm formatter options
            </summary>
        </member>
        <member name="P:Iced.Intel.MasmFormatterOptions.AddDsPrefix32">
            <summary>
            Add a DS segment override even if it's not present. Used if it's 16/32-bit code and mem op is a displ, eg. 'mov eax,[12345678]' vs 'mov eax,ds:[12345678]'
            </summary>
        </member>
        <member name="P:Iced.Intel.MasmFormatterOptions.SymbolDisplInBrackets">
            <summary>
            Show symbols in brackets, eg. '[ecx+symbol]' vs 'symbol[ecx]' and '[symbol]' vs 'symbol'
            </summary>
        </member>
        <member name="P:Iced.Intel.MasmFormatterOptions.DisplInBrackets">
            <summary>
            Show displacements in brackets, eg. '[ecx+1234h]' vs '1234h[ecx]'
            </summary>
        </member>
        <member name="M:Iced.Intel.MasmFormatterOptions.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Iced.Intel.MasmFormatter">
            <summary>
            Masm formatter
            </summary>
        </member>
        <member name="P:Iced.Intel.MasmFormatter.Options">
            <summary>
            Gets the formatter options, see also <see cref="P:Iced.Intel.MasmFormatter.MasmOptions"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.MasmFormatter.MasmOptions">
            <summary>
            Gets the masm formatter options
            </summary>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.#ctor(Iced.Intel.MasmFormatterOptions,Iced.Intel.ISymbolResolver,Iced.Intel.IFormatterOptionsProvider)">
            <summary>
            Constructor
            </summary>
            <param name="options">Formatter options or null</param>
            <param name="symbolResolver">Symbol resolver or null</param>
            <param name="optionsProvider">Operand options provider or null</param>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatMnemonic(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput,Iced.Intel.FormatMnemonicOptions)">
            <summary>
            Formats the mnemonic and any prefixes
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
            <param name="options">Options</param>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.GetOperandCount(Iced.Intel.Instruction@)">
            <summary>
            Gets the number of operands that will be formatted. A formatter can add and remove operands
            </summary>
            <param name="instruction">Instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.TryGetOpAccess(Iced.Intel.Instruction@,System.Int32,Iced.Intel.OpAccess@)">
            <summary>
            Returns the operand access but only if it's an operand added by the formatter. If it's an
            operand that is part of <see cref="T:Iced.Intel.Instruction"/>, you should call eg.
            <see cref="M:Iced.Intel.Instruction.GetInfo"/> or <see cref="M:Iced.Intel.InstructionInfoFactory.GetInfo(Iced.Intel.Instruction@)"/>.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.MasmFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
            <param name="access">Updated with operand access if successful</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.GetInstructionOperand(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Converts a formatter operand index to an instruction operand index. Returns -1 if it's an operand added by the formatter
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.MasmFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.GetFormatterOperand(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Converts an instruction operand index to a formatter operand index. Returns -1 if the instruction operand isn't used by the formatter
            </summary>
            <param name="instruction">Instruction</param>
            <param name="instructionOperand">Instruction operand</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatOperand(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput,System.Int32)">
            <summary>
            Formats an operand. This is a formatter operand and not necessarily a real instruction operand.
            A formatter can add and remove operands.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.MasmFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatOperandSeparator(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats an operand separator
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatAllOperands(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats all operands
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.Format(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats the whole instruction: prefixes, mnemonic, operands
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.Format(Iced.Intel.Register)">
            <summary>
            Formats a register
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatInt8(System.SByte,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.SByte"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatInt16(System.Int16,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int16"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatInt32(System.Int32,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int32"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatInt64(System.Int64,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int64"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatUInt8(System.Byte,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Byte"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatUInt16(System.UInt16,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt16"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatUInt32(System.UInt32,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MasmFormatter.FormatUInt64(System.UInt64,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt64"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.MemoryOperand">
            <summary>
            Memory operand
            </summary>
        </member>
        <member name="F:Iced.Intel.MemoryOperand.SegmentPrefix">
            <summary>
            Segment override or <see cref="F:Iced.Intel.Register.None"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemoryOperand.Base">
            <summary>
            Base register or <see cref="F:Iced.Intel.Register.None"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemoryOperand.Index">
            <summary>
            Index register or <see cref="F:Iced.Intel.Register.None"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemoryOperand.Scale">
            <summary>
            Index register scale (1, 2, 4, or 8)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemoryOperand.Displacement">
            <summary>
            Memory displacement
            </summary>
        </member>
        <member name="F:Iced.Intel.MemoryOperand.DisplSize">
            <summary>
            0 (no displ), 1 (16/32/64-bit, but use 2/4/8 if it doesn't fit in a <see cref="T:System.SByte"/>), 2 (16-bit), 4 (32-bit) or 8 (64-bit)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemoryOperand.IsBroadcast">
            <summary>
            true if it's broadcasted memory (EVEX instructions)
            </summary>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register,Iced.Intel.Register,System.Int32,System.Int32,System.Int32,System.Boolean,Iced.Intel.Register)">
            <summary>
            Constructor
            </summary>
            <param name="base">Base register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="index">Index register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="scale">Index register scale (1, 2, 4, or 8)</param>
            <param name="displacement">Memory displacement</param>
            <param name="displSize">0 (no displ), 1 (16/32/64-bit, but use 2/4/8 if it doesn't fit in a <see cref="T:System.SByte"/>), 2 (16-bit), 4 (32-bit) or 8 (64-bit)</param>
            <param name="isBroadcast">true if it's broadcasted memory (EVEX instructions)</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register,Iced.Intel.Register,System.Int32,System.Boolean,Iced.Intel.Register)">
            <summary>
            Constructor
            </summary>
            <param name="base">Base register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="index">Index register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="scale">Index register scale (1, 2, 4, or 8)</param>
            <param name="isBroadcast">true if it's broadcasted memory (EVEX instructions)</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register,System.Int32,System.Int32,System.Boolean,Iced.Intel.Register)">
            <summary>
            Constructor
            </summary>
            <param name="base">Base register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="displacement">Memory displacement</param>
            <param name="displSize">0 (no displ), 1 (16/32/64-bit, but use 2/4/8 if it doesn't fit in a <see cref="T:System.SByte"/>), 2 (16-bit), 4 (32-bit) or 8 (64-bit)</param>
            <param name="isBroadcast">true if it's broadcasted memory (EVEX instructions)</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register,System.Int32,System.Int32,System.Int32,System.Boolean,Iced.Intel.Register)">
            <summary>
            Constructor
            </summary>
            <param name="index">Index register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="scale">Index register scale (1, 2, 4, or 8)</param>
            <param name="displacement">Memory displacement</param>
            <param name="displSize">0 (no displ), 1 (16/32/64-bit, but use 2/4/8 if it doesn't fit in a <see cref="T:System.SByte"/>), 2 (16-bit), 4 (32-bit) or 8 (64-bit)</param>
            <param name="isBroadcast">true if it's broadcasted memory (EVEX instructions)</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register,System.Int32,System.Boolean,Iced.Intel.Register)">
            <summary>
            Constructor
            </summary>
            <param name="base">Base register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="displacement">Memory displacement</param>
            <param name="isBroadcast">true if it's broadcasted memory (EVEX instructions)</param>
            <param name="prefixSegment">Segment override or <see cref="F:Iced.Intel.Register.None"/></param>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register,Iced.Intel.Register,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="base">Base register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="index">Index register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="scale">Index register scale (1, 2, 4, or 8)</param>
            <param name="displacement">Memory displacement</param>
            <param name="displSize">0 (no displ), 1 (16/32/64-bit, but use 2/4/8 if it doesn't fit in a <see cref="T:System.SByte"/>), 2 (16-bit), 4 (32-bit) or 8 (64-bit)</param>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register,Iced.Intel.Register,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="base">Base register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="index">Index register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="scale">Index register scale (1, 2, 4, or 8)</param>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="base">Base register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="displacement">Memory displacement</param>
            <param name="displSize">0 (no displ), 1 (16/32/64-bit, but use 2/4/8 if it doesn't fit in a <see cref="T:System.SByte"/>), 2 (16-bit), 4 (32-bit) or 8 (64-bit)</param>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="index">Index register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="scale">Index register scale (1, 2, 4, or 8)</param>
            <param name="displacement">Memory displacement</param>
            <param name="displSize">0 (no displ), 1 (16/32/64-bit, but use 2/4/8 if it doesn't fit in a <see cref="T:System.SByte"/>), 2 (16-bit), 4 (32-bit) or 8 (64-bit)</param>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="base">Base register or <see cref="F:Iced.Intel.Register.None"/></param>
            <param name="displacement">Memory displacement</param>
        </member>
        <member name="M:Iced.Intel.MemoryOperand.#ctor(Iced.Intel.Register)">
            <summary>
            Constructor
            </summary>
            <param name="base">Base register or <see cref="F:Iced.Intel.Register.None"/></param>
        </member>
        <member name="T:Iced.Intel.MemorySize">
            <summary>
            Size of a memory reference
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Unknown">
            <summary>
            Unknown size or the instruction doesn't reference the memory (eg. <c>lea</c>)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.UInt8">
            <summary>
            Memory location contains a <see cref="T:System.Byte"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.UInt16">
            <summary>
            Memory location contains a <see cref="T:System.UInt16"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.UInt32">
            <summary>
            Memory location contains a <see cref="T:System.UInt32"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.UInt52">
            <summary>
            Memory location contains a 52-bit unsigned integer
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.UInt64">
            <summary>
            Memory location contains a <see cref="T:System.UInt64"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.UInt128">
            <summary>
            Memory location contains a uint128
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.UInt256">
            <summary>
            Memory location contains a uint256
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.UInt512">
            <summary>
            Memory location contains a uint512
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Int8">
            <summary>
            Memory location contains a <see cref="T:System.SByte"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Int16">
            <summary>
            Memory location contains a <see cref="T:System.Int16"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Int32">
            <summary>
            Memory location contains a <see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Int64">
            <summary>
            Memory location contains a <see cref="T:System.Int64"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Int128">
            <summary>
            Memory location contains a int128
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Int256">
            <summary>
            Memory location contains a int256
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Int512">
            <summary>
            Memory location contains a int512
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.SegPtr16">
            <summary>
            Memory location contains a seg:ptr pair, <see cref="T:System.UInt16"/> (offset) + <see cref="T:System.UInt16"/> (segment/selector)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.SegPtr32">
            <summary>
            Memory location contains a seg:ptr pair, <see cref="T:System.UInt32"/> (offset) + <see cref="T:System.UInt16"/> (segment/selector)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.SegPtr64">
            <summary>
            Memory location contains a seg:ptr pair, <see cref="T:System.UInt64"/> (offset) + <see cref="T:System.UInt16"/> (segment/selector)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.WordOffset">
            <summary>
            Memory location contains a 16-bit offset (jmp/call word ptr [mem])
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.DwordOffset">
            <summary>
            Memory location contains a 32-bit offset (jmp/call dword ptr [mem])
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.QwordOffset">
            <summary>
            Memory location contains a 64-bit offset (jmp/call qword ptr [mem])
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Bound16_WordWord">
            <summary>
            Memory location contains two <see cref="T:System.UInt16"/>s (16-bit bound)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Bound32_DwordDword">
            <summary>
            Memory location contains two <see cref="T:System.UInt32"/>s (32-bit bound)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Bnd32">
            <summary>
            32-bit bndmov, 2 x uint32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Bnd64">
            <summary>
            64-bit bndmov, 2 x uint64
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Fword6">
            <summary>
            Memory location contains a 16-bit limit and a 32-bit address (eg. lgdtw, lgdtd)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Fword10">
            <summary>
            Memory location contains a 16-bit limit and a 64-bit address (eg. lgdtq)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Float16">
            <summary>
            Memory location contains an 16-bit floating point value
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Float32">
            <summary>
            Memory location contains a <see cref="T:System.Single"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Float64">
            <summary>
            Memory location contains a <see cref="T:System.Double"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Float80">
            <summary>
            Memory location contains an 80-bit floating point value
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Float128">
            <summary>
            Memory location contains a float128
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.BFloat16">
            <summary>
            Memory location contains a bfloat16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.FpuEnv14">
            <summary>
            Memory location contains a 14-byte FPU environment (16-bit fldenv/fstenv)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.FpuEnv28">
            <summary>
            Memory location contains a 28-byte FPU environment (32/64-bit fldenv/fstenv)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.FpuState94">
            <summary>
            Memory location contains a 94-byte FPU environment (16-bit fsave/frstor)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.FpuState108">
            <summary>
            Memory location contains a 108-byte FPU environment (32/64-bit fsave/frstor)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Fxsave_512Byte">
            <summary>
            Memory location contains 512-bytes of fxsave/fxrstor data
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Fxsave64_512Byte">
            <summary>
            Memory location contains 512-bytes of fxsave64/fxrstor64 data
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Xsave">
            <summary>
            32-bit XSAVE area
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Xsave64">
            <summary>
            64-bit XSAVE area
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Bcd">
            <summary>
            Memory location contains a 10-byte bcd value (fbld/fbstp)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed16_UInt8">
            <summary>
            16 bit location: 2 x uint8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed16_Int8">
            <summary>
            16 bit location: 2 x int8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed32_UInt8">
            <summary>
            32 bit location: 4 x uint8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed32_Int8">
            <summary>
            32 bit location: 4 x int8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed32_UInt16">
            <summary>
            32 bit location: 2 x uint16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed32_Int16">
            <summary>
            32 bit location: 2 x int16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed32_BFloat16">
            <summary>
            32 bit location: 2 x bfloat16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed64_UInt8">
            <summary>
            64-bit location: 8 x uint8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed64_Int8">
            <summary>
            64-bit location: 8 x int8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed64_UInt16">
            <summary>
            64-bit location: 4 x uint16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed64_Int16">
            <summary>
            64-bit location: 4 x int16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed64_UInt32">
            <summary>
            64-bit location: 2 x uint32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed64_Int32">
            <summary>
            64-bit location: 2 x int32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed64_Float16">
            <summary>
            64-bit location: 4 x float16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed64_Float32">
            <summary>
            64-bit location: 2 x float32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_UInt8">
            <summary>
            128 bit location: 16 x uint8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_Int8">
            <summary>
            128 bit location: 16 x int8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_UInt16">
            <summary>
            128 bit location: 8 x uint16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_Int16">
            <summary>
            128 bit location: 8 x int16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_UInt32">
            <summary>
            128 bit location: 4 x uint32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_Int32">
            <summary>
            128 bit location: 4 x int32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_UInt52">
            <summary>
            128 bit location: 2 x uint52
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_UInt64">
            <summary>
            128 bit location: 2 x uint64
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_Int64">
            <summary>
            128 bit location: 2 x int64
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_Float16">
            <summary>
            128 bit location: 8 x float16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_Float32">
            <summary>
            128 bit location: 4 x float32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_Float64">
            <summary>
            128 bit location: 2 x float64
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed128_2xBFloat16">
            <summary>
            128 bit location: 4 x (2 x bfloat16)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_UInt8">
            <summary>
            256 bit location: 32 x uint8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_Int8">
            <summary>
            256 bit location: 32 x int8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_UInt16">
            <summary>
            256 bit location: 16 x uint16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_Int16">
            <summary>
            256 bit location: 16 x int16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_UInt32">
            <summary>
            256 bit location: 8 x uint32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_Int32">
            <summary>
            256 bit location: 8 x int32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_UInt52">
            <summary>
            256 bit location: 4 x uint52
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_UInt64">
            <summary>
            256 bit location: 4 x uint64
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_Int64">
            <summary>
            256 bit location: 4 x int64
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_UInt128">
            <summary>
            256 bit location: 2 x uint128
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_Int128">
            <summary>
            256 bit location: 2 x int128
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_Float16">
            <summary>
            256 bit location: 16 x float16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_Float32">
            <summary>
            256 bit location: 8 x float32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_Float64">
            <summary>
            256 bit location: 4 x float64
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_Float128">
            <summary>
            256 bit location: 2 x float128
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed256_2xBFloat16">
            <summary>
            256 bit location: 8 x (2 x bfloat16)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_UInt8">
            <summary>
            512 bit location: 64 x uint8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_Int8">
            <summary>
            512 bit location: 64 x int8
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_UInt16">
            <summary>
            512 bit location: 32 x uint16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_Int16">
            <summary>
            512 bit location: 32 x int16
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_UInt32">
            <summary>
            512 bit location: 16 x uint32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_Int32">
            <summary>
            512 bit location: 16 x int32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_UInt52">
            <summary>
            512 bit location: 8 x uint52
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_UInt64">
            <summary>
            512 bit location: 8 x uint64
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_Int64">
            <summary>
            512 bit location: 8 x int64
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_UInt128">
            <summary>
            256 bit location: 4 x uint128
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_Float32">
            <summary>
            512 bit location: 16 x float32
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_Float64">
            <summary>
            512 bit location: 8 x float64
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Packed512_2xBFloat16">
            <summary>
            512 bit location: 16 x (2 x bfloat16)
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast64_UInt32">
            <summary>
            Broadcast uint32 to 64 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast64_Int32">
            <summary>
            Broadcast int32 to 64 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast64_Float32">
            <summary>
            Broadcast float32 to 64 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_UInt32">
            <summary>
            Broadcast uint32 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_Int32">
            <summary>
            Broadcast int32 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_UInt52">
            <summary>
            Broadcast uint52 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_UInt64">
            <summary>
            Broadcast uint64 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_Int64">
            <summary>
            Broadcast int64 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_Float32">
            <summary>
            Broadcast float32 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_Float64">
            <summary>
            Broadcast float64 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_UInt32">
            <summary>
            Broadcast uint32 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_Int32">
            <summary>
            Broadcast int32 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_UInt52">
            <summary>
            Broadcast uint52 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_UInt64">
            <summary>
            Broadcast uint64 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_Int64">
            <summary>
            Broadcast int64 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_Float32">
            <summary>
            Broadcast float32 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_Float64">
            <summary>
            Broadcast float64 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_UInt32">
            <summary>
            Broadcast uint32 to 512 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_Int32">
            <summary>
            Broadcast int32 to 512 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_UInt52">
            <summary>
            Broadcast uint52 to 512 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_UInt64">
            <summary>
            Broadcast uint64 to 512 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_Int64">
            <summary>
            Broadcast int64 to 512 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_Float32">
            <summary>
            Broadcast float32 to 512 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_Float64">
            <summary>
            Broadcast float64 to 512 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_2xInt16">
            <summary>
            Broadcast 2 x int16 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_2xInt16">
            <summary>
            Broadcast 2 x int16 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_2xInt16">
            <summary>
            Broadcast 2 x int16 to 512 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_2xUInt32">
            <summary>
            Broadcast 2 x uint32 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_2xUInt32">
            <summary>
            Broadcast 2 x uint32 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_2xUInt32">
            <summary>
            Broadcast 2 x uint32 to 512 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_2xInt32">
            <summary>
            Broadcast 2 x int32 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_2xInt32">
            <summary>
            Broadcast 2 x int32 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_2xInt32">
            <summary>
            Broadcast 2 x int32 to 512 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast128_2xBFloat16">
            <summary>
            Broadcast 2 x bfloat16 to 128 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast256_2xBFloat16">
            <summary>
            Broadcast 2 x bfloat16 to 256 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.MemorySize.Broadcast512_2xBFloat16">
            <summary>
            Broadcast 2 x bfloat16 to 512 bits
            </summary>
        </member>
        <member name="T:Iced.Intel.MemorySizeExtensions">
            <summary>
            <see cref="T:Iced.Intel.MemorySize"/> extension methods
            </summary>
            <summary>
            <see cref="T:Iced.Intel.MemorySize"/> extension methods
            </summary>
        </member>
        <member name="M:Iced.Intel.MemorySizeExtensions.GetInfo(Iced.Intel.MemorySize)">
            <summary>
            Gets the memory size info
            </summary>
            <param name="memorySize">Memory size</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MemorySizeExtensions.GetSize(Iced.Intel.MemorySize)">
            <summary>
            Gets the size in bytes of the memory location or 0 if it's not accessed by the instruction or unknown or variable sized
            </summary>
            <param name="memorySize">Memory size</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MemorySizeExtensions.GetElementSize(Iced.Intel.MemorySize)">
            <summary>
            Gets the size in bytes of the packed element. If it's not a packed data type, it's equal to <see cref="M:Iced.Intel.MemorySizeExtensions.GetSize(Iced.Intel.MemorySize)"/>.
            </summary>
            <param name="memorySize">Memory size</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MemorySizeExtensions.GetElementType(Iced.Intel.MemorySize)">
            <summary>
            Gets the element type if it's packed data or <paramref name="memorySize"/> if it's not packed data
            </summary>
            <param name="memorySize">Memory size</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MemorySizeExtensions.IsSigned(Iced.Intel.MemorySize)">
            <summary>
            true if it's signed data (signed integer or a floating point value)
            </summary>
            <param name="memorySize">Memory size</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MemorySizeExtensions.IsPacked(Iced.Intel.MemorySize)">
            <summary>
            true if this is a packed data type, eg. <see cref="F:Iced.Intel.MemorySize.Packed128_Float32"/>
            </summary>
            <param name="memorySize">Memory size</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MemorySizeExtensions.GetElementCount(Iced.Intel.MemorySize)">
            <summary>
            Gets the number of elements in the packed data type or 1 if it's not packed data (<see cref="M:Iced.Intel.MemorySizeExtensions.IsPacked(Iced.Intel.MemorySize)"/>)
            </summary>
            <param name="memorySize">Memory size</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.MemorySizeExtensions.IsBroadcast(Iced.Intel.MemorySize)">
            <summary>
            Checks if <paramref name="memorySize"/> is a broadcast memory type
            </summary>
            <param name="memorySize">Memory size</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.MemorySizeInfo">
            <summary>
            <see cref="T:Iced.Intel.MemorySize"/> information
            </summary>
        </member>
        <member name="P:Iced.Intel.MemorySizeInfo.MemorySize">
            <summary>
            Gets the <see cref="T:Iced.Intel.MemorySize"/> value
            </summary>
        </member>
        <member name="P:Iced.Intel.MemorySizeInfo.Size">
            <summary>
            Size in bytes of the memory location or 0 if it's not accessed or unknown
            </summary>
        </member>
        <member name="P:Iced.Intel.MemorySizeInfo.ElementSize">
            <summary>
            Size in bytes of the packed element. If it's not a packed data type, it's equal to <see cref="P:Iced.Intel.MemorySizeInfo.Size"/>.
            </summary>
        </member>
        <member name="P:Iced.Intel.MemorySizeInfo.ElementType">
            <summary>
            Element type if it's packed data or the type itself if it's not packed data
            </summary>
        </member>
        <member name="P:Iced.Intel.MemorySizeInfo.IsSigned">
            <summary>
            true if it's signed data (signed integer or a floating point value)
            </summary>
        </member>
        <member name="P:Iced.Intel.MemorySizeInfo.IsBroadcast">
            <summary>
            true if it's a broadcast memory type
            </summary>
        </member>
        <member name="P:Iced.Intel.MemorySizeInfo.IsPacked">
            <summary>
            true if this is a packed data type, eg. <see cref="F:Iced.Intel.MemorySize.Packed128_Float32"/>. See also <see cref="P:Iced.Intel.MemorySizeInfo.ElementCount"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.MemorySizeInfo.ElementCount">
            <summary>
            Gets the number of elements in the packed data type or 1 if it's not packed data (<see cref="P:Iced.Intel.MemorySizeInfo.IsPacked"/>)
            </summary>
        </member>
        <member name="M:Iced.Intel.MemorySizeInfo.#ctor(Iced.Intel.MemorySize,System.Int32,System.Int32,Iced.Intel.MemorySize,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="memorySize">Memory size value</param>
            <param name="size">Size of location</param>
            <param name="elementSize">Size of the packed element, or <paramref name="size"/> if it's not packed data</param>
            <param name="elementType">Element type if it's packed data or <paramref name="memorySize"/> if it's not packed data</param>
            <param name="isSigned">true if signed data</param>
            <param name="isBroadcast">true if broadcast</param>
        </member>
        <member name="T:Iced.Intel.Mnemonic">
            <summary>
            Mnemonic
            </summary>
        </member>
        <member name="T:Iced.Intel.MnemonicUtils">
            <summary>
            Extension methods
            </summary>
        </member>
        <member name="M:Iced.Intel.MnemonicUtils.ToMnemonic(Iced.Intel.Code)">
            <summary>
            Gets the mnemonic
            </summary>
            <param name="code">Code value</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.NasmFormatterOptions">
            <summary>
            Nasm formatter options
            </summary>
        </member>
        <member name="P:Iced.Intel.NasmFormatterOptions.ShowSignExtendedImmediateSize">
            <summary>
            Shows byte, word, dword or qword if it's a sign extended immediate operand value, eg. 'or rcx,-1' vs 'or rcx,byte -1'
            </summary>
        </member>
        <member name="M:Iced.Intel.NasmFormatterOptions.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Iced.Intel.NasmFormatter">
            <summary>
            Nasm formatter
            </summary>
        </member>
        <member name="P:Iced.Intel.NasmFormatter.Options">
            <summary>
            Gets the formatter options, see also <see cref="P:Iced.Intel.NasmFormatter.NasmOptions"/>
            </summary>
        </member>
        <member name="P:Iced.Intel.NasmFormatter.NasmOptions">
            <summary>
            Gets the nasm formatter options
            </summary>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.#ctor(Iced.Intel.NasmFormatterOptions,Iced.Intel.ISymbolResolver,Iced.Intel.IFormatterOptionsProvider)">
            <summary>
            Constructor
            </summary>
            <param name="options">Formatter options or null</param>
            <param name="symbolResolver">Symbol resolver or null</param>
            <param name="optionsProvider">Operand options provider or null</param>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatMnemonic(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput,Iced.Intel.FormatMnemonicOptions)">
            <summary>
            Formats the mnemonic and any prefixes
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
            <param name="options">Options</param>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.GetOperandCount(Iced.Intel.Instruction@)">
            <summary>
            Gets the number of operands that will be formatted. A formatter can add and remove operands
            </summary>
            <param name="instruction">Instruction</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.TryGetOpAccess(Iced.Intel.Instruction@,System.Int32,Iced.Intel.OpAccess@)">
            <summary>
            Returns the operand access but only if it's an operand added by the formatter. If it's an
            operand that is part of <see cref="T:Iced.Intel.Instruction"/>, you should call eg.
            <see cref="M:Iced.Intel.Instruction.GetInfo"/> or <see cref="M:Iced.Intel.InstructionInfoFactory.GetInfo(Iced.Intel.Instruction@)"/>.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.NasmFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
            <param name="access">Updated with operand access if successful</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.GetInstructionOperand(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Converts a formatter operand index to an instruction operand index. Returns -1 if it's an operand added by the formatter
            </summary>
            <param name="instruction">Instruction</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.NasmFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.GetFormatterOperand(Iced.Intel.Instruction@,System.Int32)">
            <summary>
            Converts an instruction operand index to a formatter operand index. Returns -1 if the instruction operand isn't used by the formatter
            </summary>
            <param name="instruction">Instruction</param>
            <param name="instructionOperand">Instruction operand</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatOperand(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput,System.Int32)">
            <summary>
            Formats an operand. This is a formatter operand and not necessarily a real instruction operand.
            A formatter can add and remove operands.
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
            <param name="operand">Operand number, 0-based. This is a formatter operand and isn't necessarily the same as an instruction operand.
            See <see cref="M:Iced.Intel.NasmFormatter.GetOperandCount(Iced.Intel.Instruction@)"/></param>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatOperandSeparator(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats an operand separator
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatAllOperands(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats all operands
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.Format(Iced.Intel.Instruction@,Iced.Intel.FormatterOutput)">
            <summary>
            Formats the whole instruction: prefixes, mnemonic, operands
            </summary>
            <param name="instruction">Instruction</param>
            <param name="output">Output</param>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.Format(Iced.Intel.Register)">
            <summary>
            Formats a register
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatInt8(System.SByte,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.SByte"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatInt16(System.Int16,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int16"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatInt32(System.Int32,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int32"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatInt64(System.Int64,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Int64"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatUInt8(System.Byte,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.Byte"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatUInt16(System.UInt16,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt16"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatUInt32(System.UInt32,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.NasmFormatter.FormatUInt64(System.UInt64,Iced.Intel.NumberFormattingOptions@)">
            <summary>
            Formats a <see cref="T:System.UInt64"/>
            </summary>
            <param name="value">Value</param>
            <param name="numberOptions">Options</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.OpAccess">
            <summary>
            Operand, register and memory access
            </summary>
        </member>
        <member name="F:Iced.Intel.OpAccess.None">
            <summary>
            Nothing is read and nothing is written
            </summary>
        </member>
        <member name="F:Iced.Intel.OpAccess.Read">
            <summary>
            The value is read
            </summary>
        </member>
        <member name="F:Iced.Intel.OpAccess.CondRead">
            <summary>
            The value is sometimes read and sometimes not
            </summary>
        </member>
        <member name="F:Iced.Intel.OpAccess.Write">
            <summary>
            The value is completely overwritten
            </summary>
        </member>
        <member name="F:Iced.Intel.OpAccess.CondWrite">
            <summary>
            Conditional write, sometimes it's written and sometimes it's not modified
            </summary>
        </member>
        <member name="F:Iced.Intel.OpAccess.ReadWrite">
            <summary>
            The value is read and written
            </summary>
        </member>
        <member name="F:Iced.Intel.OpAccess.ReadCondWrite">
            <summary>
            The value is read and sometimes written
            </summary>
        </member>
        <member name="F:Iced.Intel.OpAccess.NoMemAccess">
            <summary>
            The memory operand doesn't refer to memory (eg. lea instruction) or it's an instruction that doesn't
            read the data to a register or doesn't write to the memory location, it just prefetches/invalidates it,
            eg. invlpg, prefetchnta, vgatherpf0dps, etc.
            </summary>
        </member>
        <member name="T:Iced.Intel.OpCodeInfo">
            <summary>
            Opcode info
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Code">
            <summary>
            Gets the code
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Encoding">
            <summary>
            Gets the encoding
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.IsInstruction">
            <summary>
            true if it's an instruction, false if it's eg. <see cref="F:Iced.Intel.Code.INVALID"/>, db, dw, dd, dq
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Mode16">
            <summary>
            true if it's an instruction available in 16-bit mode
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Mode32">
            <summary>
            true if it's an instruction available in 32-bit mode
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Mode64">
            <summary>
            true if it's an instruction available in 64-bit mode
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Fwait">
            <summary>
            true if an fwait (9B) instruction is added before the instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.OperandSize">
            <summary>
            (Legacy encoding) Gets the required operand size (16,32,64) or 0 if no operand size prefix (66) or REX.W prefix is needed
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.AddressSize">
            <summary>
            (Legacy encoding) Gets the required address size (16,32,64) or 0 if no address size prefix (67) is needed
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.L">
            <summary>
            (VEX/XOP/EVEX) L / L'L value or default value if <see cref="P:Iced.Intel.OpCodeInfo.IsLIG"/> is true
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.W">
            <summary>
            (VEX/XOP/EVEX) W value or default value if <see cref="P:Iced.Intel.OpCodeInfo.IsWIG"/> or <see cref="P:Iced.Intel.OpCodeInfo.IsWIG32"/> is true
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.IsLIG">
            <summary>
            (VEX/XOP/EVEX) true if the L / L'L fields are ignored.
            EVEX: if reg-only ops and {er} (EVEX.b is set), L'L is the rounding control and not ignored.
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.IsWIG">
            <summary>
            (VEX/XOP/EVEX) true if the W field is ignored in 16/32/64-bit modes
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.IsWIG32">
            <summary>
            (VEX/XOP/EVEX) true if the W field is ignored in 16/32-bit modes (but not 64-bit mode)
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.TupleType">
            <summary>
            (EVEX) Gets the tuple type
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanBroadcast">
            <summary>
            (EVEX) true if the instruction supports broadcasting (EVEX.b bit) (if it has a memory operand)
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseRoundingControl">
            <summary>
            (EVEX) true if the instruction supports rounding control
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanSuppressAllExceptions">
            <summary>
            (EVEX) true if the instruction supports suppress all exceptions
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseOpMaskRegister">
            <summary>
            (EVEX) true if an opmask register can be used
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.RequireNonZeroOpMaskRegister">
            <summary>
            (EVEX) true if a non-zero opmask register must be used
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseZeroingMasking">
            <summary>
            (EVEX) true if the instruction supports zeroing masking (if one of the opmask registers k1-k7 is used)
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseLockPrefix">
            <summary>
            true if the LOCK (F0) prefix can be used
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseXacquirePrefix">
            <summary>
            true if the XACQUIRE (F2) prefix can be used
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseXreleasePrefix">
            <summary>
            true if the XRELEASE (F3) prefix can be used
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseRepPrefix">
            <summary>
            true if the REP / REPE (F3) prefixes can be used
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseRepnePrefix">
            <summary>
            true if the REPNE (F2) prefix can be used
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseBndPrefix">
            <summary>
            true if the BND (F2) prefix can be used
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseHintTakenPrefix">
            <summary>
            true if the HINT-TAKEN (3E) and HINT-NOT-TAKEN (2E) prefixes can be used
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.CanUseNotrackPrefix">
            <summary>
            true if the NOTRACK (3E) prefix can be used
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Table">
            <summary>
            Gets the opcode table
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.MandatoryPrefix">
            <summary>
            Gets the mandatory prefix
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.OpCode">
            <summary>
            Gets the opcode. 00000000xxh if it's 1-byte, 0000yyxxh if it's 2-byte (yy != 00, and yy is the first byte and xx the second byte).
            It doesn't include the table value, see <see cref="P:Iced.Intel.OpCodeInfo.Table"/>.
            Example values: 0xDFC0 (<see cref="F:Iced.Intel.Code.Ffreep_sti"/>), 0x01D8 (<see cref="F:Iced.Intel.Code.Vmrunw"/>), 0x2A (<see cref="F:Iced.Intel.Code.Sub_r8_rm8"/>, <see cref="F:Iced.Intel.Code.Cvtpi2ps_xmm_mmm64"/>, etc).
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.IsGroup">
            <summary>
            true if it's part of a group
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.GroupIndex">
            <summary>
            Group index (0-7) or -1. If it's 0-7, it's stored in the 'reg' field of the modrm byte.
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.OpCount">
            <summary>
            Gets the number of operands
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Op0Kind">
            <summary>
            Gets operand #0's opkind
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Op1Kind">
            <summary>
            Gets operand #1's opkind
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Op2Kind">
            <summary>
            Gets operand #2's opkind
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Op3Kind">
            <summary>
            Gets operand #3's opkind
            </summary>
        </member>
        <member name="P:Iced.Intel.OpCodeInfo.Op4Kind">
            <summary>
            Gets operand #4's opkind
            </summary>
        </member>
        <member name="M:Iced.Intel.OpCodeInfo.GetOpKind(System.Int32)">
            <summary>
            Gets an operand's opkind
            </summary>
            <param name="operand">Operand number</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.OpCodeInfo.IsAvailableInMode(System.Int32)">
            <summary>
            Checks if the instruction is available in 16-bit mode, 32-bit mode or 64-bit mode
            </summary>
            <param name="bitness">16, 32 or 64</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.OpCodeInfo.ToOpCodeString">
            <summary>
            Gets the opcode string, eg. "VEX.128.66.0F38.W0 78 /r", see also <see cref="M:Iced.Intel.OpCodeInfo.ToInstructionString"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.OpCodeInfo.ToInstructionString">
            <summary>
            Gets the instruction string, eg. "VPBROADCASTB xmm1, xmm2/m8", see also <see cref="M:Iced.Intel.OpCodeInfo.ToOpCodeString"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.OpCodeInfo.ToString">
            <summary>
            Gets the instruction string, eg. "VPBROADCASTB xmm1, xmm2/m8", see also <see cref="M:Iced.Intel.OpCodeInfo.ToOpCodeString"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.OpCodeOperandKind">
            <summary>
            Operand kind
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.None">
            <summary>
            No operand
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.farbr2_2">
            <summary>
            Far branch 16-bit offset, 16-bit segment/selector
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.farbr4_2">
            <summary>
            Far branch 32-bit offset, 16-bit segment/selector
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mem_offs">
            <summary>
            Memory offset without a modrm byte (eg. mov al,[offset])
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mem">
            <summary>
            Memory (modrm)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mem_mpx">
            <summary>
            Memory (modrm), MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mem_mib">
            <summary>
            Memory (modrm), MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced and must not be RIP relative
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mem_vsib32x">
            <summary>
            Memory (modrm), vsib32, xmm registers
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mem_vsib64x">
            <summary>
            Memory (modrm), vsib64, xmm registers
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mem_vsib32y">
            <summary>
            Memory (modrm), vsib32, ymm registers
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mem_vsib64y">
            <summary>
            Memory (modrm), vsib64, ymm registers
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mem_vsib32z">
            <summary>
            Memory (modrm), vsib32, zmm registers
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mem_vsib64z">
            <summary>
            Memory (modrm), vsib64, zmm registers
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r8_or_mem">
            <summary>
            8-bit GPR or memory
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r16_or_mem">
            <summary>
            16-bit GPR or memory
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r32_or_mem">
            <summary>
            32-bit GPR or memory
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r32_or_mem_mpx">
            <summary>
            32-bit GPR or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r64_or_mem">
            <summary>
            64-bit GPR or memory
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r64_or_mem_mpx">
            <summary>
            64-bit GPR or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mm_or_mem">
            <summary>
            MM register or memory
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.xmm_or_mem">
            <summary>
            XMM register or memory
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.ymm_or_mem">
            <summary>
            YMM register or memory
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.zmm_or_mem">
            <summary>
            ZMM register or memory
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.bnd_or_mem_mpx">
            <summary>
            BND register or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.k_or_mem">
            <summary>
            K register or memory
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r8_reg">
            <summary>
            8-bit GPR encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r8_opcode">
            <summary>
            8-bit GPR encoded in the low 3 bits of the opcode
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r16_reg">
            <summary>
            16-bit GPR encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r16_rm">
            <summary>
            16-bit GPR encoded in the 'mod + r/m' fields of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r16_opcode">
            <summary>
            16-bit GPR encoded in the low 3 bits of the opcode
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r32_reg">
            <summary>
            32-bit GPR encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r32_rm">
            <summary>
            32-bit GPR encoded in the 'mod + r/m' fields of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r32_opcode">
            <summary>
            32-bit GPR encoded in the low 3 bits of the opcode
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r32_vvvv">
            <summary>
            32-bit GPR encoded in the the V'vvvv field (VEX/EVEX/XOP)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r64_reg">
            <summary>
            64-bit GPR encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r64_rm">
            <summary>
            64-bit GPR encoded in the 'mod + r/m' fields of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r64_opcode">
            <summary>
            64-bit GPR encoded in the low 3 bits of the opcode
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.r64_vvvv">
            <summary>
            64-bit GPR encoded in the the V'vvvv field (VEX/EVEX/XOP)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.seg_reg">
            <summary>
            Segment register encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.k_reg">
            <summary>
            K register encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.kp1_reg">
            <summary>
            K register (+1) encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.k_rm">
            <summary>
            K register encoded in the 'mod + r/m' fields of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.k_vvvv">
            <summary>
            K register encoded in the the V'vvvv field (VEX/EVEX/XOP)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mm_reg">
            <summary>
            MM register encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.mm_rm">
            <summary>
            MM register encoded in the 'mod + r/m' fields of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.xmm_reg">
            <summary>
            XMM register encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.xmm_rm">
            <summary>
            XMM register encoded in the 'mod + r/m' fields of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.xmm_vvvv">
            <summary>
            XMM register encoded in the the V'vvvv field (VEX/EVEX/XOP)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.xmmp3_vvvv">
            <summary>
            XMM register (+3) encoded in the the V'vvvv field (VEX/EVEX/XOP)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.xmm_is4">
            <summary>
            XMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only XMM0-XMM15)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.xmm_is5">
            <summary>
            XMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only XMM0-XMM15)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.ymm_reg">
            <summary>
            YMM register encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.ymm_rm">
            <summary>
            YMM register encoded in the 'mod + r/m' fields of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.ymm_vvvv">
            <summary>
            YMM register encoded in the the V'vvvv field (VEX/EVEX/XOP)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.ymm_is4">
            <summary>
            YMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only YMM0-YMM15)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.ymm_is5">
            <summary>
            YMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only YMM0-YMM15)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.zmm_reg">
            <summary>
            ZMM register encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.zmm_rm">
            <summary>
            ZMM register encoded in the 'mod + r/m' fields of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.zmm_vvvv">
            <summary>
            ZMM register encoded in the the V'vvvv field (VEX/EVEX/XOP)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.zmmp3_vvvv">
            <summary>
            ZMM register (+3) encoded in the the V'vvvv field (VEX/EVEX/XOP)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.cr_reg">
            <summary>
            CR register encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.dr_reg">
            <summary>
            DR register encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.tr_reg">
            <summary>
            TR register encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.bnd_reg">
            <summary>
            BND register encoded in the 'reg' field of the modrm byte
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.es">
            <summary>
            ES register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.cs">
            <summary>
            CS register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.ss">
            <summary>
            SS register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.ds">
            <summary>
            DS register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.fs">
            <summary>
            FS register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.gs">
            <summary>
            GS register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.al">
            <summary>
            AL register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.cl">
            <summary>
            CL register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.ax">
            <summary>
            AX register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.dx">
            <summary>
            DX register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.eax">
            <summary>
            EAX register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.rax">
            <summary>
            RAX register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.st0">
            <summary>
            ST0 register
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.sti_opcode">
            <summary>
            ST(i) register encoded in the low 3 bits of the opcode
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.imm2_m2z">
            <summary>
            2-bit immediate (m2z field, low 2 bits of the /is5 immediate, eg. vpermil2ps)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.imm8">
            <summary>
            8-bit immediate
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.imm8_const_1">
            <summary>
            Constant 1 (8-bit immediate)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.imm8sex16">
            <summary>
            8-bit immediate sign extended to 16 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.imm8sex32">
            <summary>
            8-bit immediate sign extended to 32 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.imm8sex64">
            <summary>
            8-bit immediate sign extended to 64 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.imm16">
            <summary>
            16-bit immediate
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.imm32">
            <summary>
            32-bit immediate
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.imm32sex64">
            <summary>
            32-bit immediate sign extended to 64 bits
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.imm64">
            <summary>
            64-bit immediate
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.seg_rSI">
            <summary>
            seg:[rSI] memory operand (string instructions)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.es_rDI">
            <summary>
            es:[rDI] memory operand (string instructions)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.seg_rDI">
            <summary>
            seg:[rDI] memory operand ((v)maskmovq instructions)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.seg_rBX_al">
            <summary>
            seg:[rBX+al] memory operand (xlatb instruction)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.br16_1">
            <summary>
            16-bit branch, 1-byte signed relative offset
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.br32_1">
            <summary>
            32-bit branch, 1-byte signed relative offset
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.br64_1">
            <summary>
            64-bit branch, 1-byte signed relative offset
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.br16_2">
            <summary>
            16-bit branch, 2-byte signed relative offset
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.br32_4">
            <summary>
            32-bit branch, 4-byte signed relative offset
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.br64_4">
            <summary>
            64-bit branch, 4-byte signed relative offset
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.xbegin_2">
            <summary>
            xbegin, 2-byte signed relative offset
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.xbegin_4">
            <summary>
            xbegin, 4-byte signed relative offset
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.brdisp_2">
            <summary>
            2-byte branch offset (jmpe instruction)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeOperandKind.brdisp_4">
            <summary>
            4-byte branch offset (jmpe instruction)
            </summary>
        </member>
        <member name="T:Iced.Intel.OpCodeTableKind">
            <summary>
            Opcode table
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeTableKind.Normal">
            <summary>
            Legacy encoding table
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeTableKind.T0F">
            <summary>
            0Fxx table (legacy, VEX, EVEX)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeTableKind.T0F38">
            <summary>
            0F38xx table (legacy, VEX, EVEX)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeTableKind.T0F3A">
            <summary>
            0F3Axx table (legacy, VEX, EVEX)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeTableKind.XOP8">
            <summary>
            XOP8 table (XOP)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeTableKind.XOP9">
            <summary>
            XOP9 table (XOP)
            </summary>
        </member>
        <member name="F:Iced.Intel.OpCodeTableKind.XOPA">
            <summary>
            XOPA table (XOP)
            </summary>
        </member>
        <member name="T:Iced.Intel.OpKind">
            <summary>
            Instruction operand kind
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Register">
            <summary>
            A register (<see cref="T:Iced.Intel.Register"/>).
            
            This operand kind uses <see cref="P:Iced.Intel.Instruction.Op0Register"/>, <see cref="P:Iced.Intel.Instruction.Op1Register"/>,
            <see cref="P:Iced.Intel.Instruction.Op2Register"/> or <see cref="P:Iced.Intel.Instruction.Op3Register"/> depending on operand number.
            See also <see cref="M:Iced.Intel.Instruction.GetOpRegister(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.NearBranch16">
            <summary>
            Near 16-bit branch. This operand kind uses <see cref="P:Iced.Intel.Instruction.NearBranch16"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.NearBranch32">
            <summary>
            Near 32-bit branch. This operand kind uses <see cref="P:Iced.Intel.Instruction.NearBranch32"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.NearBranch64">
            <summary>
            Near 64-bit branch. This operand kind uses <see cref="P:Iced.Intel.Instruction.NearBranch64"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.FarBranch16">
            <summary>
            Far 16-bit branch. This operand kind uses <see cref="P:Iced.Intel.Instruction.FarBranch16"/> and <see cref="P:Iced.Intel.Instruction.FarBranchSelector"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.FarBranch32">
            <summary>
            Far 32-bit branch. This operand kind uses <see cref="P:Iced.Intel.Instruction.FarBranch32"/> and <see cref="P:Iced.Intel.Instruction.FarBranchSelector"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Immediate8">
            <summary>
            8-bit constant. This operand kind uses <see cref="P:Iced.Intel.Instruction.Immediate8"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Immediate8_2nd">
            <summary>
            8-bit constant used by the enter, extrq, insertq instructions. This operand kind uses <see cref="P:Iced.Intel.Instruction.Immediate8_2nd"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Immediate16">
            <summary>
            16-bit constant. This operand kind uses <see cref="P:Iced.Intel.Instruction.Immediate16"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Immediate32">
            <summary>
            32-bit constant. This operand kind uses <see cref="P:Iced.Intel.Instruction.Immediate32"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Immediate64">
            <summary>
            64-bit constant. This operand kind uses <see cref="P:Iced.Intel.Instruction.Immediate64"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Immediate8to16">
            <summary>
            An 8-bit value sign extended to 16 bits. This operand kind uses <see cref="P:Iced.Intel.Instruction.Immediate8to16"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Immediate8to32">
            <summary>
            An 8-bit value sign extended to 32 bits. This operand kind uses <see cref="P:Iced.Intel.Instruction.Immediate8to32"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Immediate8to64">
            <summary>
            An 8-bit value sign extended to 64 bits. This operand kind uses <see cref="P:Iced.Intel.Instruction.Immediate8to64"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Immediate32to64">
            <summary>
            A 32-bit value sign extended to 64 bits. This operand kind uses <see cref="P:Iced.Intel.Instruction.Immediate32to64"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.MemorySegSI">
            <summary>
            seg:[si]. This operand kind uses <see cref="P:Iced.Intel.Instruction.MemorySize"/>, <see cref="P:Iced.Intel.Instruction.MemorySegment"/>, <see cref="P:Iced.Intel.Instruction.SegmentPrefix"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.MemorySegESI">
            <summary>
            seg:[esi]. This operand kind uses <see cref="P:Iced.Intel.Instruction.MemorySize"/>, <see cref="P:Iced.Intel.Instruction.MemorySegment"/>, <see cref="P:Iced.Intel.Instruction.SegmentPrefix"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.MemorySegRSI">
            <summary>
            seg:[rsi]. This operand kind uses <see cref="P:Iced.Intel.Instruction.MemorySize"/>, <see cref="P:Iced.Intel.Instruction.MemorySegment"/>, <see cref="P:Iced.Intel.Instruction.SegmentPrefix"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.MemorySegDI">
            <summary>
            seg:[di]. This operand kind uses <see cref="P:Iced.Intel.Instruction.MemorySize"/>, <see cref="P:Iced.Intel.Instruction.MemorySegment"/>, <see cref="P:Iced.Intel.Instruction.SegmentPrefix"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.MemorySegEDI">
            <summary>
            seg:[edi]. This operand kind uses <see cref="P:Iced.Intel.Instruction.MemorySize"/>, <see cref="P:Iced.Intel.Instruction.MemorySegment"/>, <see cref="P:Iced.Intel.Instruction.SegmentPrefix"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.MemorySegRDI">
            <summary>
            seg:[rdi]. This operand kind uses <see cref="P:Iced.Intel.Instruction.MemorySize"/>, <see cref="P:Iced.Intel.Instruction.MemorySegment"/>, <see cref="P:Iced.Intel.Instruction.SegmentPrefix"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.MemoryESDI">
            <summary>
            es:[di]. This operand kind uses <see cref="P:Iced.Intel.Instruction.MemorySize"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.MemoryESEDI">
            <summary>
            es:[edi]. This operand kind uses <see cref="P:Iced.Intel.Instruction.MemorySize"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.MemoryESRDI">
            <summary>
            es:[rdi]. This operand kind uses <see cref="P:Iced.Intel.Instruction.MemorySize"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Memory64">
            <summary>
            64-bit offset [xxxxxxxxxxxxxxxx]. This operand kind uses <see cref="P:Iced.Intel.Instruction.MemoryAddress64"/>,
            <see cref="P:Iced.Intel.Instruction.MemorySegment"/>, <see cref="P:Iced.Intel.Instruction.SegmentPrefix"/>, <see cref="P:Iced.Intel.Instruction.MemorySize"/>
            </summary>
        </member>
        <member name="F:Iced.Intel.OpKind.Memory">
            <summary>
            Memory operand.
            
            This operand kind uses <see cref="P:Iced.Intel.Instruction.MemoryDisplSize"/>, <see cref="P:Iced.Intel.Instruction.MemorySize"/>,
            <see cref="P:Iced.Intel.Instruction.MemoryIndexScale"/>, <see cref="P:Iced.Intel.Instruction.MemoryDisplacement"/>,
            <see cref="P:Iced.Intel.Instruction.MemoryBase"/>, <see cref="P:Iced.Intel.Instruction.MemoryIndex"/>, <see cref="P:Iced.Intel.Instruction.MemorySegment"/>,
            <see cref="P:Iced.Intel.Instruction.SegmentPrefix"/>
            </summary>
        </member>
        <member name="T:Iced.Intel.Register">
            <summary>
            A register
            </summary>
        </member>
        <member name="T:Iced.Intel.RegisterExtensions">
            <summary>
            <see cref="T:Iced.Intel.Register"/> extension methods
            </summary>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.GetInfo(Iced.Intel.Register)">
            <summary>
            Gets register info
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.GetBaseRegister(Iced.Intel.Register)">
            <summary>
            Gets the base register, eg. AL, AX, EAX, RAX, MM0, XMM0, YMM0, ZMM0, ES
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.GetNumber(Iced.Intel.Register)">
            <summary>
            The register number (index) relative to <see cref="M:Iced.Intel.RegisterExtensions.GetBaseRegister(Iced.Intel.Register)"/>, eg. 0-15, or 0-31, or if 8-bit GPR, 0-19
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.GetFullRegister(Iced.Intel.Register)">
            <summary>
            Gets the full register that this one is a part of, eg. CL/CH/CX/ECX/RCX -> RCX, XMM11/YMM11/ZMM11 -> ZMM11
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.GetFullRegister32(Iced.Intel.Register)">
            <summary>
            Gets the full register that this one is a part of, except if it's a GPR in which case the 32-bit register is returned,
            eg. CL/CH/CX/ECX/RCX -> ECX, XMM11/YMM11/ZMM11 -> ZMM11
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.GetSize(Iced.Intel.Register)">
            <summary>
            Gets the size of the register in bytes
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.IsSegmentRegister(Iced.Intel.Register)">
            <summary>
            Checks if it's a segment register (ES, CS, SS, DS, FS, GS)
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.IsGPR(Iced.Intel.Register)">
            <summary>
            Checks if it's a general purpose register (AL-R15L, AX-R15W, EAX-R15D, RAX-R15)
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.IsGPR8(Iced.Intel.Register)">
            <summary>
            Checks if it's an 8-bit general purpose register (AL-R15L)
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.IsGPR16(Iced.Intel.Register)">
            <summary>
            Checks if it's a 16-bit general purpose register (AX-R15W)
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.IsGPR32(Iced.Intel.Register)">
            <summary>
            Checks if it's a 32-bit general purpose register (EAX-R15D)
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.IsGPR64(Iced.Intel.Register)">
            <summary>
            Checks if it's a 64-bit general purpose register (RAX-R15)
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.IsXMM(Iced.Intel.Register)">
            <summary>
            Checks if it's a 128-bit vector register (XMM0-XMM31)
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.IsYMM(Iced.Intel.Register)">
            <summary>
            Checks if it's a 256-bit vector register (YMM0-YMM31)
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.IsZMM(Iced.Intel.Register)">
            <summary>
            Checks if it's a 512-bit vector register (ZMM0-ZMM31)
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.RegisterExtensions.IsVectorRegister(Iced.Intel.Register)">
            <summary>
            Checks if it's an XMM, YMM or ZMM register
            </summary>
            <param name="register">Register</param>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.RegisterInfo">
            <summary>
            Register info
            </summary>
        </member>
        <member name="P:Iced.Intel.RegisterInfo.Register">
            <summary>
            Gets the register
            </summary>
        </member>
        <member name="P:Iced.Intel.RegisterInfo.Base">
            <summary>
            Gets the base register, eg. AL, AX, EAX, RAX, MM0, XMM0, YMM0, ZMM0, ES
            </summary>
        </member>
        <member name="P:Iced.Intel.RegisterInfo.Number">
            <summary>
            The register number (index) relative to <see cref="P:Iced.Intel.RegisterInfo.Base"/>, eg. 0-15, or 0-31, or if 8-bit GPR, 0-19
            </summary>
        </member>
        <member name="P:Iced.Intel.RegisterInfo.FullRegister">
            <summary>
            The full register that this one is a part of, eg. CL/CH/CX/ECX/RCX -> RCX, XMM11/YMM11/ZMM11 -> ZMM11
            </summary>
        </member>
        <member name="P:Iced.Intel.RegisterInfo.FullRegister32">
            <summary>
            Gets the full register that this one is a part of, except if it's a GPR in which case the 32-bit register is returned,
            eg. CL/CH/CX/ECX/RCX -> ECX, XMM11/YMM11/ZMM11 -> ZMM11
            </summary>
        </member>
        <member name="P:Iced.Intel.RegisterInfo.Size">
            <summary>
            Size of the register in bytes
            </summary>
        </member>
        <member name="M:Iced.Intel.RegisterInfo.#ctor(Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="register">Register</param>
            <param name="baseRegister">Base register, eg. AL, AX, EAX, RAX, XMM0, YMM0, ZMM0, ES</param>
            <param name="fullRegister">Full register, eg. RAX, ZMM0, ES</param>
            <param name="size">Size of register in bytes</param>
        </member>
        <member name="T:Iced.Intel.RflagsBits">
            <summary>
            RFLAGS bits supported by the instruction info code
            </summary>
        </member>
        <member name="T:Iced.Intel.RoundingControl">
            <summary>
            Rounding control
            </summary>
        </member>
        <member name="F:Iced.Intel.RoundingControl.None">
            <summary>
            No rounding mode
            </summary>
        </member>
        <member name="F:Iced.Intel.RoundingControl.RoundToNearest">
            <summary>
            Round to nearest (even)
            </summary>
        </member>
        <member name="F:Iced.Intel.RoundingControl.RoundDown">
            <summary>
            Round down (toward -inf)
            </summary>
        </member>
        <member name="F:Iced.Intel.RoundingControl.RoundUp">
            <summary>
            Round up (toward +inf)
            </summary>
        </member>
        <member name="F:Iced.Intel.RoundingControl.RoundTowardZero">
            <summary>
            Round toward zero (truncate)
            </summary>
        </member>
        <member name="T:Iced.Intel.StringBuilderFormatterOutput">
            <summary>
            Formatter output that stores the formatted text in a <see cref="T:System.Text.StringBuilder"/>
            </summary>
        </member>
        <member name="M:Iced.Intel.StringBuilderFormatterOutput.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Iced.Intel.StringBuilderFormatterOutput.#ctor(System.Text.StringBuilder)">
            <summary>
            Constructor
            </summary>
            <param name="sb">String builder</param>
        </member>
        <member name="M:Iced.Intel.StringBuilderFormatterOutput.Write(System.String,Iced.Intel.FormatterOutputTextKind)">
            <summary>
            Writes text and text kind
            </summary>
            <param name="text">Text, can be an empty string</param>
            <param name="kind">Text kind. This value can be identical to the previous value passed to this method. It's
            the responsibility of the implementer to merge any such strings if needed.</param>
        </member>
        <member name="M:Iced.Intel.StringBuilderFormatterOutput.Reset">
            <summary>
            Clears the <see cref="T:System.Text.StringBuilder"/> instance so this class can be reused to format the next instruction
            </summary>
        </member>
        <member name="M:Iced.Intel.StringBuilderFormatterOutput.ToStringAndReset">
            <summary>
            Returns the current formatted text and clears the <see cref="T:System.Text.StringBuilder"/> instance so this class can be reused to format the next instruction
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iced.Intel.StringBuilderFormatterOutput.ToString">
            <summary>
            Gets the current output
            </summary>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.TupleType">
            <summary>
            Tuple type (EVEX) which can be used to get the disp8 scale factor N
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.None">
            <summary>
            N = 1
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Full_128">
            <summary>
            N = b ? (W ? 8 : 4) : 16
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Full_256">
            <summary>
            N = b ? (W ? 8 : 4) : 32
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Full_512">
            <summary>
            N = b ? (W ? 8 : 4) : 64
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Half_128">
            <summary>
            N = b ? 4 : 8
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Half_256">
            <summary>
            N = b ? 4 : 16
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Half_512">
            <summary>
            N = b ? 4 : 32
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Full_Mem_128">
            <summary>
            N = 16
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Full_Mem_256">
            <summary>
            N = 32
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Full_Mem_512">
            <summary>
            N = 64
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple1_Scalar">
            <summary>
            N = W ? 8 : 4
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple1_Scalar_1">
            <summary>
            N = 1
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple1_Scalar_2">
            <summary>
            N = 2
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple1_Scalar_4">
            <summary>
            N = 4
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple1_Scalar_8">
            <summary>
            N = 8
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple1_Fixed_4">
            <summary>
            N = 4
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple1_Fixed_8">
            <summary>
            N = 8
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple2">
            <summary>
            N = W ? 16 : 8
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple4">
            <summary>
            N = W ? 32 : 16
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple8">
            <summary>
            N = W ? error : 32
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Tuple1_4X">
            <summary>
            N = 16
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Half_Mem_128">
            <summary>
            N = 8
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Half_Mem_256">
            <summary>
            N = 16
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Half_Mem_512">
            <summary>
            N = 32
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Quarter_Mem_128">
            <summary>
            N = 4
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Quarter_Mem_256">
            <summary>
            N = 8
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Quarter_Mem_512">
            <summary>
            N = 16
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Eighth_Mem_128">
            <summary>
            N = 2
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Eighth_Mem_256">
            <summary>
            N = 4
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Eighth_Mem_512">
            <summary>
            N = 8
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.Mem128">
            <summary>
            N = 16
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.MOVDDUP_128">
            <summary>
            N = 8
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.MOVDDUP_256">
            <summary>
            N = 32
            </summary>
        </member>
        <member name="F:Iced.Intel.TupleType.MOVDDUP_512">
            <summary>
            N = 64
            </summary>
        </member>
        <member name="T:Iced.Intel.UsedMemory">
            <summary>
            A memory location used by an instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.UsedMemory.Segment">
            <summary>
            Effective segment register
            </summary>
        </member>
        <member name="P:Iced.Intel.UsedMemory.Base">
            <summary>
            Base register or <see cref="F:Iced.Intel.Register.None"/> if none
            </summary>
        </member>
        <member name="P:Iced.Intel.UsedMemory.Index">
            <summary>
            Index register or <see cref="F:Iced.Intel.Register.None"/> if none
            </summary>
        </member>
        <member name="P:Iced.Intel.UsedMemory.Scale">
            <summary>
            Index scale (1, 2, 4 or 8)
            </summary>
        </member>
        <member name="P:Iced.Intel.UsedMemory.Displacement">
            <summary>
            Displacement
            </summary>
        </member>
        <member name="P:Iced.Intel.UsedMemory.MemorySize">
            <summary>
            Size of location
            </summary>
        </member>
        <member name="P:Iced.Intel.UsedMemory.Access">
            <summary>
            Memory access
            </summary>
        </member>
        <member name="M:Iced.Intel.UsedMemory.#ctor(Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,System.Int32,System.Int64,Iced.Intel.MemorySize,Iced.Intel.OpAccess)">
            <summary>
            Constructor
            </summary>
            <param name="segReg">Segment register</param>
            <param name="baseReg">Base register</param>
            <param name="indexReg">Index register</param>
            <param name="scale">Scale, 1, 2, 4 or 8</param>
            <param name="displ">Displacement</param>
            <param name="memorySize">Memory size</param>
            <param name="access">Access</param>
        </member>
        <member name="M:Iced.Intel.UsedMemory.#ctor(Iced.Intel.Register,Iced.Intel.Register,Iced.Intel.Register,System.Int32,System.UInt64,Iced.Intel.MemorySize,Iced.Intel.OpAccess)">
            <summary>
            Constructor
            </summary>
            <param name="segReg">Segment register</param>
            <param name="baseReg">Base register</param>
            <param name="indexReg">Index register</param>
            <param name="scale">Scale, 1, 2, 4 or 8</param>
            <param name="displ">Displacement</param>
            <param name="memorySize">Memory size</param>
            <param name="access">Access</param>
        </member>
        <member name="M:Iced.Intel.UsedMemory.ToString">
            <summary>
            ToString()
            </summary>
            <returns></returns>
        </member>
        <member name="T:Iced.Intel.UsedRegister">
            <summary>
            A register used by an instruction
            </summary>
        </member>
        <member name="P:Iced.Intel.UsedRegister.Register">
            <summary>
            Register
            </summary>
        </member>
        <member name="P:Iced.Intel.UsedRegister.Access">
            <summary>
            Register access
            </summary>
        </member>
        <member name="M:Iced.Intel.UsedRegister.#ctor(Iced.Intel.Register,Iced.Intel.OpAccess)">
            <summary>
            Constructor
            </summary>
            <param name="register">Register</param>
            <param name="access">Register access</param>
        </member>
        <member name="M:Iced.Intel.UsedRegister.ToString">
            <summary>
            ToString()
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
